# MoviePy


[![MoviePy page on the Python Package Index](https://badge.fury.io/py/moviepy.svg)](https://pypi.org/project/moviepy/) [![Discuss MoviePy on Gitter](https://img.shields.io/gitter/room/movie-py/gitter?color=46BC99&logo=gitter)](Gitter_) [![Build status on gh-actions](https://img.shields.io/github/actions/workflow/status/Zulko/moviepy/test_suite.yml?logo=github)](https://github.com/Zulko/moviepy/actions/workflows/test_suite.yml) [![Code coverage from coveralls.io](https://img.shields.io/coveralls/github/Zulko/moviepy/master?logo=coveralls)](https://coveralls.io/github/Zulko/moviepy?branch=master)

> [!NOTE]
> MoviePy recently upgraded to v2.0, introducing major breaking changes. You can consult the last v1 docs [here](https://zulko.github.io/moviepy/v1.0.3/) but beware that v1 is no longer maintained. For more info on how to update your code from v1 to v2, see [this guide](https://zulko.github.io/moviepy/getting_started/updating_to_v2.html).

MoviePy (online documentation [here](https://zulko.github.io/moviepy/)) is a Python library for video editing: cuts, concatenations, title insertions, video compositing (a.k.a. non-linear editing), video processing, and creation of custom effects.

MoviePy can read and write all the most common audio and video formats, including GIF, and runs on Windows/Mac/Linux, with Python 3.9+.

# Example

In this example we open a video file, select the subclip between 10 and
20 seconds, add a title at the center of the screen, and write the
result to a new file:

``` python
from moviepy import VideoFileClip, TextClip, CompositeVideoClip

# Load file example.mp4 and keep only the subclip from 00:00:10 to 00:00:20
# Reduce the audio volume to 80% of its original volume

clip = (
    VideoFileClip("long_examples/example2.mp4")
    .subclipped(10, 20)
    .with_volume_scaled(0.8)
)

# Generate a text clip. You can customize the font, color, etc.
txt_clip = TextClip(
    font="Arial.ttf",
    text="Hello there!",
    font_size=70,
    color='white'
).with_duration(10).with_position('center')

# Overlay the text clip on the first video clip
final_video = CompositeVideoClip([clip, txt_clip])
final_video.write_videofile("result.mp4")
```

# How MoviePy works

Under the hood, MoviePy imports media (video frames, images, sounds) and converts them into Python objects (numpy arrays) so that every pixel becomes accessible, and video or audio effects can be defined in just a few lines of code (see the [built-in effects]() for examples).

The library also provides ways to mix clips together (concatenations, playing clips side by side or on top of each other with transparency, etc.). The final clip is then encoded back into mp4/webm/gif/etc.

This makes MoviePy very flexible and approachable, albeit slower than using ffmpeg directly due to heavier data import/export operations.  


# Installation

Intall moviepy with `pip install moviepy`. For additional installation options, such as a custom FFMPEG or for previewing, see [this section](https://zulko.github.io/moviepy/getting_started/install.html). For development, clone that repo locally and install with `pip install -e .`

# Documentation

The online documentation ([here](https://zulko.github.io/moviepy/)) is automatically built at every push to the master branch. To build the documentation locally, install the extra dependencies via `pip install moviepy[doc]`, then go to the `docs` folder and run `make html`.

# Contribute

MoviePy is open-source software originally written by
[Zulko](https://github.com/Zulko) and released under the MIT licence.
The project is hosted on [GitHub](https://github.com/Zulko/moviepy),
where everyone is welcome to contribute and open issues or give feedback Please read our [Contributing
Guidelines](https://github.com/Zulko/moviepy/blob/master/CONTRIBUTING.md).
To ask for help or simply discuss usage and examples, use [our Reddit channel](https://www.reddit.com/r/moviepy/).

# Maintainers

## Active maintainers
-   [Zulko](https://github.com/Zulko) (owner)
-   [@osaajani](https://github.com/OsaAjani) led the development of v2 ([MR](https://github.com/Zulko/moviepy/pull/2024))
-   [@tburrows13](https://github.com/tburrows13)
-   [@keikoro](https://github.com/keikoro)

## Past maintainers and thanks
-   [@mgaitan](https://github.com/mgaitan)
-   [@earney](https://github.com/earney)
-   [@mbeacom](https://github.com/mbeacom)
-   [@overdrivr](https://github.com/overdrivr)
-   [@ryanfox](https://github.com/ryanfox)
-   [@mondeja](https://github.com/mondeja)

**Maintainers wanted!** this library has only been kept afloat by the involvement of its maintainers, and there are times where none of us have enough bandwidth. We'd love to hear about developers interested in giving a hand and solving some of the issues (especially the ones that affect you) or reviewing pull requests. Open
an issue or contact us directly if you are interested. Thanks!


--- END README.md ---



--- START moviepy/docs/index.rst ---

:notoc:

***********************
MoviePy documentation
***********************

.. image:: /_static/medias/logo.png
    :width: 50%
    :align: center

**Date**: |today| **Version**: |version|

**Useful links**:
`Binary Installers <https://pypi.org/project/moviepy/>`__ |
`Source Repository <https://github.com/Zulko/moviepy>`__ |
`Issues & Ideas <https://github.com/Zulko/moviepy>`__ |
`Q&A Support <https://www.reddit.com/r/moviepy/>`__ |

MoviePy is the `Python <https://www.python.org/>`__ reference tool for video editing automation! 

It's an open source, MIT-licensed library offering user-friendly video editing 
and manipulation tools for the `Python <https://www.python.org/>`__ programming language.

.. grid:: 1 2 2 2
    :gutter: 4
    :padding: 2 2 0 0
    :class-container: sd-text-center

    .. grid-item-card:: Getting started
        :img-top: _static/medias/index_getting_started.svg
        :class-card: intro-card
        :shadow: md

        New to *MoviePy*? Check out the getting started guides. They contain instructions
        to install *MoviePy* as well as introduction concepts and tutorials.

        +++

        .. button-ref:: getting_started
            :ref-type: ref
            :click-parent:
            :color: secondary
            :expand:

            To the starting guide

    .. grid-item-card::  User guide
        :img-top: _static/medias/index_user_guide.svg
        :class-card: intro-card
        :shadow: md

        The user guide provides in-depth information on the
        key concepts of *MoviePy* with useful background information and explanation.

        +++

        .. button-ref:: user_guide
            :ref-type: ref
            :click-parent:
            :color: secondary
            :expand:

            To the user guide

    .. grid-item-card::  API reference
        :img-top: _static/medias/index_api.svg
        :class-card: intro-card
        :shadow: md

        The reference guide contains a detailed description of
        the *MoviePy* API. The reference describes how the methods work and which parameters can
        be used. It assumes that you have an understanding of the key concepts.

        +++

        .. button-ref:: reference_manual
            :ref-type: ref
            :click-parent:
            :color: secondary
            :expand:

            To the reference guide

    .. grid-item-card::  Developer guide
        :img-top: _static/medias/index_contribute.svg
        :class-card: intro-card
        :shadow: md

        Saw a typo in the documentation? Want to improve
        existing functionalities? The contributing guidelines will guide
        you through the process of improving *MoviePy*.

        +++

        .. button-ref:: developer_guide
            :ref-type: ref
            :click-parent:
            :color: secondary
            :expand:

            To the development guide




Contribute!
--------------

MoviePy is an open source software originally written by Zulko_ and released under the MIT licence. It works on Windows, Mac, and Linux. 

.. raw:: html

    <a href="https://twitter.com/share" class="twitter-share-button"
    data-text="MoviePy - Video editing with Python" data-size="large" data-hashtags="MoviePy">Tweet
    </a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';
    if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';
    fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
    </script>

    <iframe type="text/html" src="https://ghbtns.com/github-btn.html?user=Zulko&repo=moviepy&type=watch&count=true&size=large"
    allowtransparency="true" frameborder="0" scrolling="0" width="152px" height="30px"></iframe>


.. toctree::
    :maxdepth: 3
    :hidden:
    :titlesonly:


    getting_started/index
    user_guide/index
    reference/index
    developer_guide/index


.. _PyPI: https://pypi.python.org/pypi/moviepy
.. _Zulko: https://github.com/Zulko/
.. _Stackoverflow: https://stackoverflow.com/
.. _Github: https://github.com/Zulko/moviepy
.. _Reddit: https://www.reddit.com/r/moviepy/


--- END moviepy/docs/index.rst ---



--- START moviepy/docs/Makefile ---

# Makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS    =
SPHINXBUILD   = sphinx-build
PAPER         =
BUILDDIR      = build
PDFBUILDDIR   = /tmp
PDF           = ../manual.pdf

# User-friendly check for sphinx-build
ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
endif

# Internal variables.
PAPEROPT_a4     = -D latex_paper_size=a4
PAPEROPT_letter = -D latex_paper_size=letter
ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
# the i18n builder cannot share the environment and doctrees with the others
I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .

.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext

help:
	@echo "Please use \`make <target>' where <target> is one of"
	@echo "  html       to make standalone HTML files"
	@echo "  dirhtml    to make HTML files named index.html in directories"
	@echo "  singlehtml to make a single large HTML file"
	@echo "  pickle     to make pickle files"
	@echo "  json       to make JSON files"
	@echo "  htmlhelp   to make HTML files and a HTML help project"
	@echo "  qthelp     to make HTML files and a qthelp project"
	@echo "  devhelp    to make HTML files and a Devhelp project"
	@echo "  epub       to make an epub"
	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
	@echo "  text       to make text files"
	@echo "  man        to make manual pages"
	@echo "  texinfo    to make Texinfo files"
	@echo "  info       to make Texinfo files and run them through makeinfo"
	@echo "  gettext    to make PO message catalogs"
	@echo "  changes    to make an overview of all changed/added/deprecated items"
	@echo "  xml        to make Docutils-native XML files"
	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
	@echo "  linkcheck  to check all external links for integrity"
	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"

clean:
	rm -rf $(BUILDDIR)/*

html:
	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."

dirhtml:
	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."

singlehtml:
	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
	@echo
	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."

pickle:
	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
	@echo
	@echo "Build finished; now you can process the pickle files."

json:
	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
	@echo
	@echo "Build finished; now you can process the JSON files."

htmlhelp:
	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
	@echo
	@echo "Build finished; now you can run HTML Help Workshop with the" \
	      ".hhp project file in $(BUILDDIR)/htmlhelp."

qthelp:
	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
	@echo
	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/MoviePy.qhcp"
	@echo "To view the help file:"
	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/MoviePy.qhc"

devhelp:
	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
	@echo
	@echo "Build finished."
	@echo "To view the help file:"
	@echo "# mkdir -p $$HOME/.local/share/devhelp/MoviePy"
	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/MoviePy"
	@echo "# devhelp"

epub:
	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
	@echo
	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."

latex:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo
	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
	@echo "Run \`make' in that directory to run these through (pdf)latex" \
	      "(use \`make latexpdf' here to do that automatically)."

latexpdf:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(PDFBUILDDIR)/latex
	@echo "Running LaTeX files through pdflatex..."
	$(MAKE) -C $(PDFBUILDDIR)/latex all-pdf
	cp $(PDFBUILDDIR)/latex/*.pdf $(PDF)
	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."

latexpdfja:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo "Running LaTeX files through platex and dvipdfmx..."
	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."

text:
	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
	@echo
	@echo "Build finished. The text files are in $(BUILDDIR)/text."

man:
	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
	@echo
	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."

texinfo:
	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
	@echo
	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
	@echo "Run \`make' in that directory to run these through makeinfo" \
	      "(use \`make info' here to do that automatically)."

info:
	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
	@echo "Running Texinfo files through makeinfo..."
	make -C $(BUILDDIR)/texinfo info
	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."

gettext:
	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
	@echo
	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."

changes:
	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
	@echo
	@echo "The overview file is in $(BUILDDIR)/changes."

linkcheck:
	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
	@echo
	@echo "Link check complete; look for any errors in the above output " \
	      "or in $(BUILDDIR)/linkcheck/output.txt."

doctest:
	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
	@echo "Testing of doctests in the sources finished, look at the " \
	      "results in $(BUILDDIR)/doctest/output.txt."

xml:
	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
	@echo
	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."

pseudoxml:
	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
	@echo
	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."


--- END moviepy/docs/Makefile ---



--- START moviepy/docs/conf.py ---

# -*- coding: utf-8 -*-

"""MoviePy documentation build configuration file."""

import os
import sys


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath(".."))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.autosummary",
    "sphinx.ext.napoleon",
    "sphinx_design",
    "sphinx.ext.coverage",
    "sphinx.ext.todo",
    "sphinx.ext.viewcode",
    "sphinx.ext.autosectionlabel",
]

autosectionlabel_prefix_document = True

autosummary_generate = True

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix of source filenames.
source_suffix = ".rst"

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "MoviePy"
copyright = "2025, Zulko - MIT"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = "2.2.1"

# The full version, including alpha/beta/rc tags.
# release = '0.2.3.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build"]

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

sys.path.append(os.path.abspath("_themes"))
# html_theme_path = ['_themes']
html_theme = "pydata_sphinx_theme"  # formerly 'kr'
# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
v2_page = "https://zulko.github.io/moviepy/getting_started/updating_to_v2.html"
html_theme_options = {
    "use_edit_page_button": True,
    "icon_links": [
        {
            # Label for this link
            "name": "GitHub",
            # URL where the link will redirect
            "url": "https://github.com/Zulko/moviepy/",  # required
            # Icon class (if "type": "fontawesome"), or path to local image (if
            # "type": "local")
            "icon": "fa-brands fa-square-github",
            # The type of image to be used (see below for details)
            "type": "fontawesome",
        }
    ],
    "announcement": f"""<p>MoviePy v2.0 have introduced breaking changes, see
<a href="{v2_page}">Updating from v1.X to v2.X</a> for more info.</p>""",
}

html_context = {
    "github_user": "Zulko",
    "github_repo": "moviepy",
    "github_version": "master",
    "doc_path": "docs",
}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = "_static/medias/logo_small.jpeg"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

html_css_files = [
    "moviepy.css",
]

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = "MoviePydoc"


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ("index", "MoviePy.tex", "MoviePy Documentation", "Zulko", "manual"),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [("index", "moviepy", "MoviePy Documentation", ["Zulko"], 1)]

# If true, show URL addresses after external links.
# man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (
        "index",
        "MoviePy",
        "MoviePy Documentation",
        "Zulko",
        "MoviePy",
        "One line description of project.",
        "Miscellaneous",
    ),
]

# Documents to append as an appendix to all manuals.
# texinfo_appendices = []

# If false, no module index is generated.
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
# texinfo_no_detailmenu = False


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = "MoviePy"
epub_author = "Zulko"
epub_publisher = "Zulko"
epub_copyright = "2017, Zulko"

# The language of the text. It defaults to the language option
# or en if the language is not set.
# epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
# epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
# epub_identifier = ''

# A unique identification for the text.
# epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
# epub_cover = ()

# A sequence of (type, uri, title) tuples for the guide element of content.opf.
# epub_guide = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_post_files = []

# A list of files that should not be packed into the epub file.
# epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
# epub_tocdepth = 3

# Allow duplicate toc entries.
# epub_tocdup = True

# Fix unsupported image types using the PIL.
# epub_fix_images = False

# Scale large images.
# epub_max_image_width = 0

# If 'no', URL addresses will not be shown.
# epub_show_urls = 'inline'

# If false, no index is generated.
# epub_use_index = True

# autodoc_member_order = 'bysource'


--- END moviepy/docs/conf.py ---



--- START moviepy/docs/make.bat ---

@ECHO OFF

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set BUILDDIR=build
set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
set I18NSPHINXOPTS=%SPHINXOPTS% .
if NOT "%PAPER%" == "" (
	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
)

if "%1" == "" goto help

if "%1" == "help" (
	:help
	echo.Please use `make ^<target^>` where ^<target^> is one of
	echo.  html       to make standalone HTML files
	echo.  dirhtml    to make HTML files named index.html in directories
	echo.  singlehtml to make a single large HTML file
	echo.  pickle     to make pickle files
	echo.  json       to make JSON files
	echo.  htmlhelp   to make HTML files and a HTML help project
	echo.  qthelp     to make HTML files and a qthelp project
	echo.  devhelp    to make HTML files and a Devhelp project
	echo.  epub       to make an epub
	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
	echo.  text       to make text files
	echo.  man        to make manual pages
	echo.  texinfo    to make Texinfo files
	echo.  gettext    to make PO message catalogs
	echo.  changes    to make an overview over all changed/added/deprecated items
	echo.  xml        to make Docutils-native XML files
	echo.  pseudoxml  to make pseudoxml-XML files for display purposes
	echo.  linkcheck  to check all external links for integrity
	echo.  doctest    to run all doctests embedded in the documentation if enabled
	goto end
)

if "%1" == "clean" (
	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
	del /q /s %BUILDDIR%\*
	goto end
)


%SPHINXBUILD% 2> nul
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

if "%1" == "html" (
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
	goto end
)

if "%1" == "dirhtml" (
	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
	goto end
)

if "%1" == "singlehtml" (
	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
	goto end
)

if "%1" == "pickle" (
	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the pickle files.
	goto end
)

if "%1" == "json" (
	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the JSON files.
	goto end
)

if "%1" == "htmlhelp" (
	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run HTML Help Workshop with the ^
.hhp project file in %BUILDDIR%/htmlhelp.
	goto end
)

if "%1" == "qthelp" (
	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run "qcollectiongenerator" with the ^
.qhcp project file in %BUILDDIR%/qthelp, like this:
	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\MoviePy.qhcp
	echo.To view the help file:
	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\MoviePy.ghc
	goto end
)

if "%1" == "devhelp" (
	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished.
	goto end
)

if "%1" == "epub" (
	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The epub file is in %BUILDDIR%/epub.
	goto end
)

if "%1" == "latex" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "latexpdf" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	cd %BUILDDIR%/latex
	make all-pdf
	cd %BUILDDIR%/..
	echo.
	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "latexpdfja" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	cd %BUILDDIR%/latex
	make all-pdf-ja
	cd %BUILDDIR%/..
	echo.
	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "text" (
	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The text files are in %BUILDDIR%/text.
	goto end
)

if "%1" == "man" (
	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The manual pages are in %BUILDDIR%/man.
	goto end
)

if "%1" == "texinfo" (
	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.
	goto end
)

if "%1" == "gettext" (
	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The message catalogs are in %BUILDDIR%/locale.
	goto end
)

if "%1" == "changes" (
	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
	if errorlevel 1 exit /b 1
	echo.
	echo.The overview file is in %BUILDDIR%/changes.
	goto end
)

if "%1" == "linkcheck" (
	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
	if errorlevel 1 exit /b 1
	echo.
	echo.Link check complete; look for any errors in the above output ^
or in %BUILDDIR%/linkcheck/output.txt.
	goto end
)

if "%1" == "doctest" (
	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
	if errorlevel 1 exit /b 1
	echo.
	echo.Testing of doctests in the sources finished, look at the ^
results in %BUILDDIR%/doctest/output.txt.
	goto end
)

if "%1" == "xml" (
	%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The XML files are in %BUILDDIR%/xml.
	goto end
)

if "%1" == "pseudoxml" (
	%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.
	goto end
)

:end


--- END moviepy/docs/make.bat ---



--- START moviepy/docs/makehtml.sh ---

#!/bin/sh
make clean html

# open generated HTML files
if [[ $(uname) == 'Darwin' ]]; then
    open 'build/html/index.html' -a Firefox
elif [[ $(uname) == 'Linux' ]]; then
    firefox build/html/index.html
fi


--- END moviepy/docs/makehtml.sh ---



--- START moviepy/docs/_themes/.gitignore ---

*.pyc
*.pyo
.DS_Store


--- END moviepy/docs/_themes/.gitignore ---



--- START moviepy/docs/_templates/custom_autosummary/class.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

{{ fullname | escape | underline}}

.. currentmodule:: {{ module }}

.. autoclass:: {{ objname }}
   :members:

   


--- END moviepy/docs/_templates/custom_autosummary/class.rst ---



--- START moviepy/docs/_templates/custom_autosummary/module.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
{{ fullname | escape | underline}}

{% if fullname in ['moviepy.Effect'] or '.fx.' in fullname %} {# Fix for autosummary to document abstract class #}
.. automodule:: {{ fullname }}
   :inherited-members:
{% else %}
.. automodule:: {{ fullname }}
{% endif %}
   

   {% block classes %}
   {% if classes %}
   .. rubric:: {{ _('Classes') }}

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   {% for item in classes %}
      {{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}


   {% block functions %}
   {% if functions %}
   .. rubric:: {{ _('Functions') }}

   .. autosummary::
      :toctree:
   {% for item in functions %}
      {{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}


   {% block exceptions %}
   {% if exceptions %}
   .. rubric:: {{ _('Exceptions') }}

   .. autosummary::
   {% for item in exceptions %}
      {{ item }}
   {%- endfor %}
   {% endif %}
   {% endblock %}

{% block modules %}
{% if modules %}
.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:
{% for item in modules %}
{% if not item in ['moviepy.version'] %}
   {{ item }}
{% endif %}
{%- endfor %}
{% endif %}
{% endblock %}


--- END moviepy/docs/_templates/custom_autosummary/module.rst ---



--- START moviepy/docs/user_guide/index.rst ---

.. _user_guide:

The MoviePy User Guide
------------------------------

The User Guide covers all of MoviePy's main concepts grouped by tasks (loading, editing, composing, rendering), with a presentation of the different concepts/elements relative to the tasks along with short code examples.

It is a good place for users wishing to understand more precisely one of these aspects and to discover the different MoviePy elements relative to it.

For users wanting to have a quick overview of how to use MoviePy, a better place to start is the :ref:`getting_started` section, and more specifically the :ref:`moviepy_10_minutes` tutorial.

For a full overview of MoviePy, see the :ref:`reference_manual`.

.. toctree::
   :maxdepth: 1
   
   loading
   modifying
   create_effects
   compositing
   rendering


--- END moviepy/docs/user_guide/index.rst ---



--- START moviepy/docs/user_guide/rendering.rst ---

.. _rendering:

Previewing and Saving Video Clips
=================================

Once you are done working with your clips, the final step will be to export the result into a video/image file, or sometimes to simply preview it in order to verify that everything is working as expected.

Previewing a Clip
-----------------

When you are working with a clip, you will frequently need to have a quick look at what your clip looks like, either to verify that everything is working as intended or to check how things look.

To do so, you could render your entire clip into a file, but that's a rather long task, and you only need a quick look, so a better solution exists: previewing.

Preview a Clip as a Video
~~~~~~~~~~~~~~~~~~~~~~~~~

.. warning::
    You must have ``ffplay`` installed and accessible to MoviePy to be able to use :py:func:`~moviepy.video.io.preview.preview`.
    If you're not sure, take a look :ref:`install#binaries`

The first thing you can do is to preview your clip as a video by calling the method :py:func:`~moviepy.video.io.preview.preview` on your clip:

.. literalinclude:: /_static/code/user_guide/rendering/preview.py
    :language: python

You will probably frequently want to preview only a small portion of your clip, though ``preview`` does not offer such capabilities, you can easily emulate such behavior by using :py:meth:`~moviepy.Clip.Clip.subclip`.

.. note::
    It is quite frequent for a clip preview to be out of sync or to play slower than it should. This indicates that your computer is not powerful enough to render the clip in real-time.
    
    Don't hesitate to play with the options of preview: for instance, lower the fps of the sound (11000 Hz is still fine) and the video. Also, downsizing your video with :py:meth:`~moviepy.video.VideoClip.VideoClip.resize` can help.

For more information, see :py:func:`~moviepy.video.io.preview.preview`.

.. note::
    A quite similar function is also available for :py:func:`~moviepy.audio.AudioClip.AudioClip`, see :py:func:`~moviepy.audio.io.ffplay_audiopreviewer.ffplay_audiopreview`.

Preview Just One Frame of a Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In many situations, you don't really need to preview your entire clip; seeing just one frame is enough to see how it looks and to ensure everything is going as expected.

To do so, you can use the method :py:func:`~moviepy.video.io.preview.show` on your clip, passing the frame time as an argument:

.. literalinclude:: /_static/code/user_guide/rendering/show.py
    :language: python

Contrary to video previewing, :py:func:`~moviepy.video.io.preview.show` does not require ``ffplay`` but uses the ``pillow`` ``Image.show`` function.

For more information, see :py:func:`~moviepy.video.io.preview.show`.

Showing a Clip in Jupyter Notebook
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you work with a `Jupyter Notebook <https://jupyter.org/>`_, it can be very practical to display your clip within the notebook. To do so, you can use the method :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` on your clip.

.. image:: /_static/medias/user_guide/demo_preview.jpeg
    :width: 500px
    :align: center

With :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook`, you can embed videos, images, and sounds, either from a file or directly from a clip:

.. literalinclude:: /_static/code/user_guide/rendering/display_in_notebook.py
    :language: python

.. warning::
    Note that :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` will only work if it is on the last line of the notebook cell. 

    Also, note that :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` actually embeds the clips physically in your notebook. The advantage is that you can move the notebook or put it online and the videos will work. 
    However, the drawback is that the file size of the notebook can become very large. Depending on your browser, re-computing and displaying the video multiple times can take up space in the cache and the RAM (this will only be a problem for intensive uses).
    Restarting your browser solves the problem.

For more information, see :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook`.

Saving Your Clip into a File
----------------------------

Once you are satisfied with how your clip looks, you can save it into a file, a step known in video editing as rendering. MoviePy offers various ways to save your clip.

Video Files (.mp4, .webm, .ogv, ...)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The obvious first choice will be to write your clip to a video file, which you can do with :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`:

.. literalinclude:: /_static/code/user_guide/rendering/write_videofile.py
    :language: python

MoviePy can automatically find the default codec names for the most common file extensions. If you want to use exotic formats or if you are not happy with the defaults, you can provide the codec with ``codec='mpeg4'`` for instance.

There are many options when you are writing a video (bitrate, parameters of the audio writing, file size optimization, number of processors to use, etc.), and we will not go into detail about each. For more information, see :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`.

.. note::
    Although you are encouraged to experiment with the settings of ``write_videofile``, know that lowering the optimization preset or increasing the number of threads will not necessarily improve the rendering time, as the bottleneck may be in MoviePy's computation of each frame and not in ffmpeg encoding.

    Also, know that it is possible to pass additional parameters to the ffmpeg command line invoked by MoviePy by using the ``ffmpeg_params`` argument.

Sometimes it is impossible for MoviePy to guess the ``duration`` attribute of the clip (keep in mind that some clips, like ImageClips displaying a picture, have *a priori* an infinite duration). In such cases, the ``duration`` must be set manually with :py:meth:`~moviepy.Clip.Clip.with_duration`:

.. literalinclude:: /_static/code/user_guide/rendering/write_videofile_duration.py
    :language: python

.. note::
    A quite similar function is also available for :py:func:`~moviepy.audio.AudioClip.AudioClip`, see :py:func:`~moviepy.audio.io.AudioClip.write_audiofile`.

Export a Single Frame of the Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As with previewing, sometimes you will need to export only one frame of a clip, for example to create the preview image of a video. You can do so with :py:meth:`~moviepy.video.VideoClip.VideoClip.save_frame`:

.. literalinclude:: /_static/code/user_guide/rendering/save_frame.py
    :language: python

For more information, see :py:func:`~moviepy.video.VideoClip.VideoClip.save_frame`.

Animated GIFs
~~~~~~~~~~~~~

In addition to writing video files, MoviePy also lets you write GIF files with :py:meth:`~moviepy.video.VideoClip.VideoClip.write_gif`:

.. literalinclude:: /_static/code/user_guide/rendering/write_gif.py
    :language: python

For more information, see :py:func:`~moviepy.video.VideoClip.VideoClip.write_gif`.

Export All the Clip as Images in a Directory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lastly, you might wish to export an entire clip as an image sequence (multiple images in one directory, one image per frame). You can do so with the function :py:meth:`~moviepy.video.VideoClip.VideoClip.write_images_sequence`:

.. literalinclude:: /_static/code/user_guide/rendering/write_images_sequence.py
    :language: python

For more information, see :py:func:`~moviepy.video.VideoClip.VideoClip.write_images_sequence`.
```


--- END moviepy/docs/user_guide/rendering.rst ---



--- START moviepy/docs/user_guide/compositing.rst ---

.. _compositing:

Compositing Multiple Clips
=========================================

Video composition, also known as non-linear editing, is the process of mixing and playing several clips together in a new clip. This video is a good example of what compositing you can do with MoviePy:

.. raw:: html

    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; margin-bottom:30px; height: 0; overflow: hidden; margin-left:15%;">
        <iframe type="text/html" src="https://youtube.com/embed/rIehsqqYFEM?rel=0" frameborder="0"
        style="position: absolute; top: 0; bottom: 10; width: 70%; height: 100%; "></iframe>
    </div>

.. note::
    Before starting, note that video clips generally carry an audio track and a mask, which are also clips. When you compose these clips together, the soundtrack and mask of the final clip are automatically generated by putting together the soundtracks and masks of the clips.
    So most of the time you don't need to worry about mixing the audio and masks.

Juxtaposing and Concatenating Clips
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Two simple ways of putting clips together are to concatenate them (to play them one after the other in a single long clip) or to juxtapose them (to put them side by side in a single larger clip).

Concatenating Multiple Clips
"""""""""""""""""""""""""""""""""

Concatenation can be done very easily with the function :py:func:`~moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips`.

.. literalinclude:: /_static/code/user_guide/compositing/concatenate.py
    :language: python

The ``final_clip`` is a clip that plays the clips 1, 2, and 3 one after the other.

.. note::
    The clips do not need to be the same size. If they aren't, they will all appear centered in a clip large enough to contain the biggest of them, with optionally a color of your choosing to fill the background.

For more info, see :py:func:`~moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips`.

Juxtaposing Multiple Clips
""""""""""""""""""""""""""""""

Putting multiple clips side by side is done with :py:func:`~moviepy.video.compositing.CompositeVideoClip.clip_array`:

.. literalinclude:: /_static/code/user_guide/compositing/juxtaposing.py
    :language: python

You obtain a clip which looks like this:

.. figure:: /_static/medias/user_guide/stacked.jpeg
   :align: center

For more info, see :py:func:`~moviepy.video.compositing.CompositeVideoClip.clip_array`.

More Complex Video Compositing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` class is the base of all video compositing.
For example, internally, both :py:func:`~moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips` and :py:func:`~moviepy.video.compositing.CompositeVideoClip.clip_array` create a :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

It provides a very flexible way to compose clips by layering multiple clips on top of each other, in the order they have been passed to :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`. Here's an example:

.. literalinclude:: /_static/code/user_guide/compositing/CompositeVideoClip.py
    :language: python

Now ``final_clip`` plays all clips at the same time, with ``clip3`` over ``clip2`` over ``clip1``. It means that, if all clips have the same size, then only ``clip3``, which is on top, will be visible in the video...

Unless ``clip3`` and/or ``clip2`` have masks which hide parts of them.

.. note::
    Note that by default the composition has the size of its first clip (as it is generally a *background*). But sometimes you will want to make your clips *float* in a bigger composition.
    To do so, just pass the size of the final composition as ``size`` parameter of :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

For now we have stacked multiple clips on top of each other, but this is obviously not enough for doing real video compositing.
For that, we will need to change when some clips start and stop playing, as well as define the x:y position of these clips in the final video.

For more info, see :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

Changing Starting and Stopping Times of Clips
""""""""""""""""""""""""""""""""""""""""""""""""

In a CompositionClip, each clip starts to play at a time that is specified by its ``clip.start`` attribute, and will play until ``clip.end``.

So, considering that you would want to play ``clip1`` for the first 6 seconds, ``clip2`` 5 seconds after the start of the video, and finally ``clip3`` at the end of ``clip2``, you would do as follows:

.. literalinclude:: /_static/code/user_guide/compositing/with_start.py
    :language: python

.. note::
    When working with timing of your clips, you will frequently want to keep only parts of the original clip.
    To do so, you should take a look at :py:meth:`~moviepy.Clip.Clip.subclipped` and :py:meth:`~moviepy.Clip.Clip.with_section_cut_out`.

Positioning Clips
""""""""""""""""""

Frequently, you will want a smaller clip to appear on top of a larger one and decide where it will appear in the composition by setting their position.

You can do so by using the :py:meth:`~moviepy.video.VideoClip.VideoClip.with_position` method. The position is always defined from the top left corner, but you can define it in many ways:

.. literalinclude:: /_static/code/user_guide/compositing/with_position.py
    :language: python

When indicating the position, keep in mind that the ``y`` coordinate has its zero at the top of the picture:

.. figure:: /_static/medias/user_guide/videoWH.jpeg

Adding Transition Effects
""""""""""""""""""""""""""

The last part of composition is adding transition effects. For example, when a clip starts while another is still playing, it would be nice to make the new one fade-in instead of showing abruptly.

To do so, we can use the transitions offered by MoviePy in :py:mod:`~moviepy.video.compositing.transitions`, like :py:func:`~moviepy.video.compositing.transitions.crossfadein`:

.. literalinclude:: /_static/code/user_guide/compositing/crossfadein.py
    :language: python

MoviePy offers only a few transitions in :py:mod:`~moviepy.video.compositing.transitions`. But technically, transitions are mostly effects applied to the mask of a clip!
That means you can actually use any of the already existing effects and use them as transitions by applying them on the mask of your clip (see :py:mod:`moviepy.video.fx`).

For more info, see :py:mod:`~moviepy.video.compositing.transitions` and :py:mod:`~moviepy.video.fx`.

Compositing Audio Clips
-----------------------

When you mix video clips together, MoviePy will automatically compose their respective audio tracks to form the audio track of the final clip, so you don't need to worry about compositing these tracks yourself.

If you want to make a custom audio track from several audio sources, audio clips can be mixed together like video clips, with :py:class:`~moviepy.audio.AudioClip.CompositeAudioClip` and :py:func:`~moviepy.audio.AudioClip.concatenate_audioclips`:

.. literalinclude:: /_static/code/user_guide/compositing/CompositeAudioClip.py
    :language: python


--- END moviepy/docs/user_guide/compositing.rst ---



--- START moviepy/docs/user_guide/create_effects.rst ---

.. _create_effects:

Creating Your Own Effects
========================================================

In addition to the existing effects already offered by MoviePy, we can create our own effects to modify a clip however we want.

Why Create Your Own Effects?
------------------------------------

For simple enough tasks, we've seen that we can :ref:`modify <filters>`. Though it might be enough for simple tasks, filters are kind of limited:

- They can only access the frame and/or timepoint.
- We cannot pass arguments to them.
- They are hard to maintain and reuse.

To allow for more complex and reusable clip modifications, we can create our own custom effects, which we will later apply with :py:func:`~moviepy.Clip.Clip.with_effects`.

For example, imagine we want to add a progress bar to a clip. To do so, we will not only need the time and image of the current frame but also the total duration of the clip. We will also probably want to be able to pass parameters to define the appearance of the progress bar, such as color or height. This is a perfect task for an effect!

Creating an Effect
--------------------

In MoviePy, effects are objects of type :py:class:`moviepy.Effect.Effect`, which is the base abstract class for all effects (similar to how :py:class:`~moviepy.Clip.Clip` is the base for all :py:class:`~moviepy.video.VideoClip.VideoClip` and :py:class:`~moviepy.audio.AudioClip.AudioClip`).

So, to create an effect, we will need to inherit the :py:class:`~moviepy.Effect.Effect` class and do two things:

- Create an ``__init__`` method to be able to receive the parameters of our effect.
- Implement the inherited :py:meth:`~moviepy.Effect.Effect.apply` method, which must take as an argument the clip we want to modify and return the modified version.

In the end, your effect will probably use :py:func:`~moviepy.Clip.Clip.time_transform`, :py:func:`~moviepy.Clip.Clip.image_transform`, or :py:func:`~moviepy.Clip.Clip.transform` to really apply your modifications to the clip. The main difference is that because your filter will be a method or an anonymous function inside your effect class, you will be able to access all properties of your object from it!

So, let's see how we could create our progress bar effect:

.. literalinclude:: /_static/code/user_guide/effects/custom_effect.py
    :language: python

.. note::
    When creating an effect, you frequently have to write boilerplate code for assigning properties on object initialization. ``dataclasses`` is a nice way to limit that.

If you want to create your own effects, in addition to this documentation, we strongly encourage you to go and take a look at the existing ones (see :py:mod:`moviepy.video.fx` and :py:mod:`moviepy.audio.fx`) to see how they work and take inspiration.


--- END moviepy/docs/user_guide/create_effects.rst ---



--- START moviepy/docs/user_guide/loading.rst ---

.. _loading:

Loading Resources as Clips
===================================

The first step for making a video with MoviePy is to load the resources you wish to include in the final video.

In this section, we present the different types of clips and how to load them.
For information on modifying a clip, see :ref:`modifying`. For how to put clips together, see :ref:`compositing`. And for how to see/save them, see :ref:`rendering` (we will usually save them in examples, but we won't explain here).

There are many different resources you can use with MoviePy, and you will load different resources with different subtypes of :py:class:`~moviepy.Clip.Clip`, and more precisely of :py:class:`~moviepy.audio.AudioClip.AudioClip` for any audio element, or :py:class:`~moviepy.video.VideoClip.VideoClip` for any visual element.

The following code summarizes the base clips that you can create with MoviePy:

.. literalinclude:: /_static/code/user_guide/loading/loading.py
    :language: python

To understand all these clips more thoroughly, read the full documentation for each in the :ref:`reference_manual`.

Releasing Resources by Closing a Clip
-------------------------------------

When you create certain types of clip instances—e.g., ``VideoFileClip`` or ``AudioFileClip``—MoviePy creates a subprocess and locks the file. To release these resources when you are finished, you should call the ``close()`` method.

This is more important for more complex applications and is particularly important when running on Windows. While Python's garbage collector should eventually clean up the resources for you, closing them makes them available earlier.

However, if you close a clip too early, methods on the clip (and any clips derived from it) become unsafe.

So, the rules of thumb are:

* Call ``close()`` on any clip that you **construct** once you have finished using it and have also finished using any clip that was derived from it.
* Even if you close a :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` instance, you still need to close the clips it was created from.
* Otherwise, if you have a clip that was created by deriving it from another clip (e.g., by calling ``with_mask()``), then generally you shouldn't close it. Closing the original clip will also close the copy.

Clips act as `context managers <https://docs.python.org/3/reference/datamodel.html#context-managers>`_. This means you can use them with a ``with`` statement, and they will automatically be closed at the end of the block, even if there is an exception.

.. literalinclude:: /_static/code/user_guide/loading/closing.py
    :language: python

Categories of Video Clips
--------------------------

Video clips are the building blocks of longer videos. Technically, they are clips with a ``clip.get_frame(t)`` method which outputs a ``HxWx3`` numpy array representing the frame of the clip at time ``t``.

There are two main types of video clips:

* Animated clips (made with :py:class:`~moviepy.video.VideoClip.VideoFileClip`, :py:class:`~moviepy.video.VideoClip.VideoClip`, and :py:class:`~moviepy.video.io.ImageSequenceClip.ImageSequenceClip`), which will always have duration.
* Unanimated clips (made with :py:class:`~moviepy.video.VideoClip.ImageClip`, :py:class:`~moviepy.video.VideoClip.TextClip`, and :py:class:`~moviepy.video.VideoClip.ColorClip`), which show the same picture for an a-priori infinite duration.

There are also special video clips called masks, which belong to the categories above but output greyscale frames indicating which parts of another clip are visible or not.

A video clip can carry around an audio clip (:py:class:`~moviepy.audio.AudioClip.AudioClip`) in :py:attr:`~moviepy.video.VideoClip.VideoClip.audio` which is its *soundtrack*, and a mask clip in :py:attr:`~moviepy.video.VideoClip.VideoClip.mask`.

Animated Clips
~~~~~~~~~~~~~~~

These are clips whose image will change over time, and which have a duration and a number of Frames Per Second.

VideoClip
"""""""""

:py:class:`~moviepy.video.VideoClip.VideoClip` is the base class for all other video clips in MoviePy. If all you want is to edit video files, you will never need it. This class is practical when you want to make animations from frames that are generated by another library. 

All you need is to define a function ``frame_function(t)`` which returns a `HxWx3` numpy array (of 8-bits integers) representing the frame at time ``t``.

Here is an example where we will create a pulsating red circle with the graphical library `Pillow <https://pypi.org/project/Pillow/>`_.

.. literalinclude:: /_static/code/user_guide/loading/VideoClip.py
    :language: python

Resulting in this:

.. image:: /_static/medias/user_guide/circle.gif
   :width: 128 px
   :align: center
   :alt: A pulsating red circle on black background.

.. note::
    Clips that are made with a ``frame_function`` do not have an explicit frame rate nor duration by default, so you must provide duration at clip creation and a frame rate (``fps``, frames per second) for :py:meth:`~moviepy.video.VideoClip.VideoClip.write_gif` and :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`, and more generally for any methods that require iterating through the frames.

For more, see :py:class:`~moviepy.video.VideoClip.VideoClip`.

VideoFileClip
"""""""""""""""

A :py:class:`~moviepy.video.io.VideoFileClip.VideoFileClip` is a clip read from a video file (most formats are supported) or a GIF file. This is probably one of the most used objects! You load the video as follows:

.. literalinclude:: /_static/code/user_guide/loading/VideoFileClip.py
    :language: python

.. note::
    These clips will have an ``fps`` (frame per second) and ``duration`` attributes, which will be transmitted if you do small modifications of the clip, and will be used by default in :py:meth:`~moviepy.video.VideoClip.VideoClip.write_gif`, :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`, etc.

For more, see :py:class:`~moviepy.video.io.VideoFileClip.VideoFileClip`.

ImageSequenceClip
""""""""""""""""""

This :py:class:`~moviepy.video.io.ImageSequenceClip.ImageSequenceClip` is a clip made from a series of images:

.. literalinclude:: /_static/code/user_guide/loading/ImageSequenceClip.py
    :language: python

When creating an image sequence, ``sequence`` can be either a list of image names (that will be *played* in the provided order), a folder name (played in alphanumerical order), or a list of frames (Numpy arrays), obtained for instance from other clips.

.. warning::
    All the images in the list/folder/frames must be of the same size, or an exception will be raised.

For more, see :py:class:`~moviepy.video.io.ImageSequenceClip.ImageSequenceClip`.

DataVideoClip
"""""""""""""""

:py:class:`~moviepy.video.io.VideoClip.DataVideoClip` is a video clip that takes a list of datasets, a callback function, and makes each frame by iterating over the dataset and invoking the callback function with the current data as the first argument.

You will probably never use this. But if you do, think of it like a :py:class:`~moviepy.video.VideoClip.VideoClip`, where you make frames not based on time, but based on each entry of a data list.

.. literalinclude:: /_static/code/user_guide/loading/DataVideoClip.py
    :language: python

For more, see :py:class:`~moviepy.video.io.VideoClip.DataVideoClip`.

UpdatedVideoClip
""""""""""""""""""

.. warning::
    This is really advanced usage; you will probably never need it. If you do, please go read the code.

:py:class:`~moviepy.video.io.VideoClip.UpdatedVideoClip` is a video whose frame_function requires some objects to be updated before we can compute it.

This is particularly practical in science where some algorithms need to make some steps before a new frame can be generated, or maybe when trying to make a video based on a live exterior context.

When you use this, you pass a world object to it. A world object is an object that respects these 3 rules:

#. It has a ``clip_t`` property, indicating the current world time.
#. It has an ``update()`` method, that will update the world state and is responsible for increasing ``clip_t`` when a new frame can be drawn.
#. It has a ``to_frame()`` method, that will render a frame based on the world's current state.

On :py:meth:`~moviepy.video.io.VideoClip.UpdatedVideoClip.get_frame` call, your :py:class:`~moviepy.video.io.VideoClip.UpdatedVideoClip` will try to update the world until ``world.clip_t`` is superior or equal to frame time, then it will call ``world.to_frame()``.

.. literalinclude:: /_static/code/user_guide/loading/UpdatedVideoClip.py
    :language: python

Unanimated Clips
~~~~~~~~~~~~~~~~

These are clips whose image will, at least before modifications, stay the same. By default, they have no duration nor FPS, meaning you will need to define them before doing operations needing such information (for example, rendering).

ImageClip
"""""""""

:py:class:`~moviepy.video.VideoClip.ImageClip` is the base class for all unanimated clips; it's a video clip that always displays the same image. Along with :py:class:`~moviepy.video.io.VideoFileClip.VideoFileClip`, it's one of the most used kinds of clips.

You can create one as follows:

.. literalinclude:: /_static/code/user_guide/loading/ImageClip.py
    :language: python

For more, see :py:class:`~moviepy.video.VideoClip.ImageClip`.

TextClip
"""""""""

A :py:class:`~moviepy.video.VideoClip.TextClip` is a clip that will turn a text string into an image clip.

:py:class:`~moviepy.video.VideoClip.TextClip` accepts many parameters, letting you configure the appearance of the text, such as font and font size, color, interlining, text alignment, etc.

The font you want to use must be an `OpenType font <https://fr.wikipedia.org/wiki/OpenType>`_, and you will set it by passing the path to the font file.

Here are a few examples of using :py:class:`~moviepy.video.VideoClip.TextClip`:

.. literalinclude:: /_static/code/user_guide/loading/TextClip.py
    :language: python

.. note::
    The parameter ``method`` lets you define if text should be written and overflow if too long (``label``) or be automatically broken over multiple lines (``caption``).

For a more detailed explanation of all the parameters, see :py:class:`~moviepy.video.VideoClip.TextClip`.

ColorClip
"""""""""

A :py:class:`~moviepy.video.VideoClip.ColorClip` is a clip that will return an image of only one color. It is sometimes useful when doing compositing (see :ref:`compositing`).

.. literalinclude:: /_static/code/user_guide/loading/ColorClip.py
    :language: python

For more, see :py:class:`~moviepy.video.VideoClip.ColorClip`.

.. _loading#masks:

Mask Clips
~~~~~~~~~~~~~~

Masks are a special kind of :py:class:`~moviepy.video.VideoClip.VideoClip` with the property ``is_mask`` set to ``True``. They can be attached to any other kind of :py:class:`~moviepy.video.VideoClip.VideoClip` through method :py:meth:`~moviepy.video.VideoClip.VideoClip.with_mask`.

When a clip has a mask attached to it, this mask will indicate which pixels will be visible when the clip is composed with other clips (see :ref:`compositing`). Masks are also used to define transparency when you export the clip as GIF file or as a PNG.

The fundamental difference between masks and standard clips is that standard clips output frames with 3 components (R-G-B) per pixel, comprised between 0 and 255, while a mask has just one component per pixel, between 0 and 1 (1 indicating a fully visible pixel and 0 a transparent pixel). Seen otherwise, a mask is always in greyscale.

When you create or load a clip that you will use as a mask, you need to declare it. You can then attach it to a clip with the same dimensions:

.. literalinclude:: /_static/code/user_guide/loading/masks.py
    :language: python

.. note::
    In the case of video and image files, if these are not already black and white, they will be converted automatically.

    Also, when you load an image with an *alpha layer*, like a PNG, MoviePy will use this layer as a mask unless you pass ``transparent=False``.

Any video clip can be turned into a mask with :py:meth:`~moviepy.video.VideoClip.VideoClip.to_mask`, and a mask can be turned to a standard RGB video clip with :py:meth:`~moviepy.video.VideoClip.VideoClip.to_RGB()`.

Masks are treated differently by many methods (because their frames are different) but at the core, they are :py:class:`~moviepy.video.VideoClip.VideoClip`, so you can do with them everything you can do with a video clip: modify, cut, apply effects, save, etc.

Using Audio Elements with Audio Clips
-------------------------------------

In addition to :py:class:`~moviepy.video.VideoClip.VideoClip` for visuals, you can use audio elements, like an audio file, using the :py:class:`~moviepy.audio.AudioClip.AudioClip` class.

Both are quite similar, except :py:class:`~moviepy.audio.AudioClip.AudioClip` method :py:meth:`~moviepy.audio.AudioClip.AudioClip.get_frame` returns a numpy array of size ``Nx1`` for mono, and size ``Nx2`` for stereo.

AudioClip
~~~~~~~~~~

:py:class:`~moviepy.audio.AudioClip.AudioClip` is the base class for all audio clips. If all you want is to edit audio files, you will never need it.

All you need is to define a function ``frame_function(t)`` which returns a ``Nx1`` or ``Nx2`` numpy array representing the sound at time ``t``.

.. literalinclude:: /_static/code/user_guide/loading/AudioClip.py
    :language: python

For more, see :py:class:`~moviepy.audio.AudioClip.AudioClip`.

AudioFileClip
"""""""""""""""""

:py:class:`~moviepy.audio.io.AudioFileClip.AudioFileClip` is used to load an audio file. This is probably the only kind of audio clip you will use.

You simply pass it the file you want to load:

.. literalinclude:: /_static/code/user_guide/loading/AudioFileClip.py
    :language: python

For more, see :py:class:`~moviepy.audio.io.AudioFileClip.AudioFileClip`.

AudioArrayClip
"""""""""""""""""

:py:class:`~moviepy.audio.AudioClip.AudioArrayClip` is used to turn an array representing a sound into an audio clip. You will probably never use it unless you need to use the result of some third-party library without using a temporary file.

You need to provide a numpy array representing the sound (of size ``Nx1`` for mono, ``Nx2`` for stereo), and the number of fps, indicating the speed at which the sound is supposed to be played.

.. literalinclude:: /_static/code/user_guide/loading/AudioArrayClip.py
    :language: python

For more, see :py:class:`~moviepy.audio.AudioClip.AudioArrayClip`.


--- END moviepy/docs/user_guide/loading.rst ---



--- START moviepy/docs/user_guide/modifying.rst ---

.. _modifying:

Modifying clips and apply effects
===================================

Of course, once you will have loaded a :py:class:`~moviepy.Clip.Clip` the next step of action will be to modify it to be able to integrate it in your final video.

To modify a clip, there is three main courses of actions :
 * The built-in methods of :py:class:`~moviepy.video.VideoClip.VideoClip` or :py:class:`~moviepy.audio.AudioClip.AudioClip` modifying the properties of the object.
 * The already-implemented effects of MoviePy you can apply on clips, usually affecting the clip by applying filters on each frame of the clip at rendering time.
 * The transformation filters that you can apply using :py:func:`~moviepy.Clip.Clip.transform` and :py:func:`~moviepy.Clip.Clip.time_transform`.


How modifications are applied to a clip ?
-------------------------------------------------------

Clip copy during modification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first thing you must know is that when modifying a clip, MoviePy **will never modify that clip directly**. 
Instead it will return **a modified copy of the original** and let the original untouched. This is known as out-place instead of in-place behavior.

To illustrate:

.. literalinclude:: /_static/code/user_guide/effects/modify_copy_example.py
    :language: python

This is an important point to understand, because it is one of the most recurrent source of bug for newcomers.


Memory consumption of effect and modifications 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When applying an effect or modification, it does not immediately apply the effect to all the frames of the clip, but only to the first frame: all the other frames will only be modified when required (that is, when you will write the whole clip to a file or when you will preview it). 

It means that creating a new clip is neither time nor memory hungry, all the computation happen during the final rendering.


Time representations in MoviePy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Many methods that we will see accept duration or timepoint as arguments. For instance :py:meth:`clip.subclipped(t_start, t_end) <moviepy.Clip.Clip.subclipped(t_start, t_end)>` which cuts the clip between two timepoints.

MoviePy usually accept duration and timepoint as either: 

* a number of seconds as a ``float``.
* a ``tuple`` with ``(minutes, seconds)`` or ``(hours, minutes, seconds)``.
* a ``string`` such as ``'00:03:50.54'``.

Also, you can usually provide negative times, indicating a time from the end of the clip. For example, ``clip.subclipped(-20, -10)`` cuts the clip between 20s before the end and 10s before the end.


Modify a clip using the ``with_*`` methods
-------------------------------------------------------

The first way to modify a clip is by modifying internal properties of your object, thus modifying his behavior.

These methods usually start with the prefix ``with_`` or ``without_``, indicating that they will return a copy of the clip with the properties modified.

So, you may write something like:

.. literalinclude:: /_static/code/user_guide/effects/using_with_methods.py
    :language: python

In addition to the ``with_*`` methods, a handful of very common methods are also accessible under shorter names:

- :py:meth:`~moviepy.video.VideoClip.VideoClip.resized`
- :py:meth:`~moviepy.video.VideoClip.VideoClip.crop`
- :py:meth:`~moviepy.video.VideoClip.VideoClip.rotate`

For a list of all those methods, see :py:class:`~moviepy.Clip.Clip` and :py:class:`~moviepy.video.VideoClip.VideoClip`.


.. _modifying#effects:

Modify a clip using effects 
---------------------------------

The second way to modify a clip is by using effects that will modify the frames of the clip (which internally are no more than `numpy arrays <https://numpy.org>`_)  by applying some sort of functions on them.

MoviePy come with many effects implemented in :py:mod:`moviepy.video.fx` for visual effects and :py:mod:`moviepy.audio.fx` for audio effects. 
For practicality, these two modules are loaded in MoviePy as ``vfx`` and ``afx``, letting you import them as ``from moviepy import vfx, afx``.

To use these effects, you simply need to instantiate them as object and apply them on your :py:class:`~moviepy.Clip.Clip` using method :py:meth:`~moviepy.Clip.Clip.with_effects`, with a list of :py:class:`~moviepy.Effect.Effect` objects you want to apply. 

For convenience the effects are also dynamically added as method of :py:class:`~moviepy.video.VideoClip.VideoClip` and :py:class:`~moviepy.video.AudioClip.AudioClip`  classes at runtime, letting you call them as simple method of your clip.

So, you may write something like:

.. literalinclude:: /_static/code/user_guide/effects/using_effects.py
    :language: python

.. note::
    MoviePy effects are automatically applied to both the sound and the mask of the clip if it is relevant, so that you don't have to worry about modifying these.

For a list of those effects, see :py:mod:`moviepy.video.fx` and :py:mod:`moviepy.audio.fx`.

In addition to the effects already provided by MoviePy, you can obviously :ref:`create_effects` and use them the same way.

.. _modifying#filters:

Modify a clip appearance and timing using filters
----------------------------------------------------------

In addition to modifying a clip's properties and using effects, you can also modify the appearance or timing of a clip by using your own custom *filters* with :py:func:`~moviepy.Clip.Clip.time_transform`, :py:func:`~moviepy.Clip.Clip.image_transform`, and more generally with :py:func:`~moviepy.Clip.Clip.transform`.

All these methods work by taking as first parameter a callback function that will receive either a clip frame, a timepoint, or both, and return a modified version of these.

Modify only the timing of a Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can change the timeline of the clip with :py:meth:`time_transform(your_filter) <moviepy.Clip.Clip.time_transform>`.
Where ``your_filter`` is a callback function taking clip time as a parameter and returning a new time:

.. literalinclude:: /_static/code/user_guide/effects/time_transform.py
    :language: python

Now the clip ``modified_clip1`` plays three times faster than ``my_clip``, while ``modified_clip2`` will be oscillating between 00:00:00 to 00:00:02 of ``my_clip``. Note that in the last case you have created a clip of infinite duration (which is not a problem for the moment).

.. note::
    By default :py:func:`~moviepy.Clip.Clip.time_transform` will only modify the clip main frame, without modifying clip audio or mask for :py:class:`~moviepy.video.VideoClip.VideoClip`. 
    
    If you wish to also modify audio and/or mask you can provide the parameter ``apply_to`` with either ``'audio'``, ``'mask'``, or ``['audio', 'mask']``. 


Modifying only the appearance of a Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For :py:class:`~moviepy.video.VideoClip.VideoClip`, you can change the appearance of the clip with :py:meth:`image_transform(your_filter) <moviepy.video.VideoClip.VideoClip.image_transform>`.
Where ``your_filter`` is a callback function, taking clip frame (a numpy array) as a parameter and returning the transformed frame:

.. literalinclude:: /_static/code/user_guide/effects/image_transform.py
    :language: python

Now the clip ``modified_clip1`` will have his green and blue canals inverted.

.. note::
    You can define if transformation should be applied to audio and mask same as for :py:func:`~moviepy.Clip.Clip.time_transform`.

.. note::
    Sometimes need to treat clip frames and mask frames in a different way. To distinguish between the two, you can always look at their shape, clips are ``H*W*3``, and masks ``H*W``.


Modifying both the appearance and the timing of a Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally, you may want to process the clip by taking into account both the time and the frame picture, for example to apply visual effects variating with time. 
This is possible with the method :py:meth:`transform(your_filter) <moviepy.Clip.Clip.transform>`.
Where ``your_filter`` is a callback function taking two parameters, and returning a new frame picture. Where first argument is a ``get_frame`` method (i.e. a function ``get_frame(time)`` which given a time returns the clip’s frame at that time), and the second argument is the time.

.. literalinclude:: /_static/code/user_guide/effects/transform.py
    :language: python

This will scroll down the clip, with a constant height of 360 pixels.

.. note::
    You can define if transformation should be applied to audio and mask same as for :py:func:`~moviepy.Clip.Clip.time_transform`. 

.. note::
    When programming a new effect, whenever it is possible, prefer using ``time_transform`` and ``image_transform`` instead of ``transform`` when implementing new effects.
    The reason is that, though they both internally rely on ``transform`` when these effects are applied to ``ImageClip`` objects, MoviePy will recognize they only need to be applied once instead of on each frame, resulting in faster renderings.

To keep things simple, we have only addressed the case of :py:class:`~moviepy.video.VideoClip.VideoClip`, but know that the same principle applies to :py:class:`~moviepy.audio.AudioClip.AudioClip`, except that instead of a picture frame, you will have an audio frame, which is also a numpy array.


--- END moviepy/docs/user_guide/modifying.rst ---



--- START moviepy/docs/_static/moviepy.css ---

@import url(flasky.css)
/* Override some aspects of the pydata-sphinx-theme */

.indexwrapper .sphinxsidebar { visibility: hidden; }

.logo img.logo { width: 120px; height: 120px; padding-right: 30px; }

div.body h1, div.body h2, div.body h3, div.body h4, div.body h5, div.body h6
  { font-family: 'Times New Roman', 'Garamond', 'Georgia', serif; }


:root {
  /* Use softer blue from bootstrap's default info color */
  --pst-color-info: 23, 162, 184;
}

table {
  width: auto; /* Override fit-content which breaks Styler user guide ipynb */
}

/* Main index page overview cards */

.intro-card {
  padding: 30px 10px 20px 10px;
}

.intro-card .sd-card-img-top {
  margin: 10px;
  height: 52px;
  background: none !important;
}

.intro-card .sd-card-title {
  color: var(--pst-color-primary);
  font-size: var(--pst-font-size-h5);
  padding: 1rem 0rem 0.5rem 0rem;
}

.intro-card .sd-card-footer {
  border: none !important;
}

.intro-card .sd-card-footer p.sd-card-text {
  max-width: 220px;
  margin-left: auto;
  margin-right: auto;
}

.intro-card .sd-btn-secondary {
  background-color: #6c757d !important;
  border-color: #6c757d !important;
}

.intro-card .sd-btn-secondary:hover {
  background-color: #5a6268 !important;
  border-color: #545b62 !important;
}

.card, .card img {
  background-color: var(--pst-color-background);
}


--- END moviepy/docs/_static/moviepy.css ---



--- START moviepy/docs/_static/code/user_guide/loading/DataVideoClip.py ---

"""Let's make a clip where frames depend on values in a list"""

from moviepy import DataVideoClip
import numpy as np

# Dataset will just be a list of colors as RGB
dataset = [
    (255, 0, 0),
    (0, 255, 0),
    (0, 0, 255),
    (0, 255, 255),
    (255, 0, 255),
    (255, 255, 0),
]


# The function make frame take data and create an image of 200x100 px
# filled with the color given in the dataset
def frame_function(data):
    frame = np.full((100, 200, 3), data, dtype=np.uint8)
    return frame


# We create the DataVideoClip, and we set FPS at 2, making a 3s clip
# (because len(dataset) = 6, so 6/2=3)
myclip = DataVideoClip(data=dataset, data_to_frame=frame_function, fps=2)

# Modifying fps here will change video FPS, not clip FPS
myclip.write_videofile("result.mp4", fps=30)


--- END moviepy/docs/_static/code/user_guide/loading/DataVideoClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/loading.py ---

import numpy as np

from moviepy import (
    AudioClip,
    AudioFileClip,
    ColorClip,
    ImageClip,
    ImageSequenceClip,
    TextClip,
    VideoClip,
    VideoFileClip,
)


# Define some constants for later use
black = (255, 255, 255)  # RGB for black


def frame_function(t):
    """Random noise image of 200x100"""
    return np.random.randint(low=0, high=255, size=(100, 200, 3))


def frame_function_audio(t):
    """A note by producing a sinewave of 440 Hz"""
    return np.sin(440 * 2 * np.pi * t)


# Now lets see how to load different type of resources !

# VIDEO CLIPS
# for custom animations, where frame_function is a function returning an image
# as numpy array for a given time
clip = VideoClip(frame_function, duration=5)
clip = VideoFileClip("example.mp4")  # for videos
# for a list or directory of images to be used as a video sequence
clip = ImageSequenceClip("example_img_dir", fps=24)
clip = ImageClip("example.png")  # For a picture
# To create the image of a text
clip = TextClip(font="./example.ttf", text="Hello!", font_size=70, color="black")
# a clip of a single unified color, where color is a RGB tuple/array/list
clip = ColorClip(size=(460, 380), color=black)

# AUDIO CLIPS
# for audio files, but also videos where you only want the keep the audio track
clip = AudioFileClip("example.wav")
# for custom audio, where frame_function is a function returning a
# float (or tuple for stereo) for a given time
clip = AudioClip(frame_function_audio, duration=3)


--- END moviepy/docs/_static/code/user_guide/loading/loading.py ---



--- START moviepy/docs/_static/code/user_guide/loading/TextClip.py ---

from moviepy import TextClip

font = "./example.ttf"

# First we use as string and let system autocalculate clip dimensions to fit the text
# we set clip duration to 2 secs, if we do not, it got an infinite duration
txt_clip1 = TextClip(
    font=font,
    text="Hello World !",
    font_size=30,
    color="#FF0000",  # Red
    bg_color="#FFFFFF",
    duration=2,
)
# This time we load text from a file, we set a fixed size for clip and let the system find best font size,
# allowing for line breaking
txt_clip2 = TextClip(
    font=font,
    filename="./example.txt",
    size=(500, 200),
    bg_color="#FFFFFF",
    method="caption",
    color=(0, 0, 255, 127),
)  # Blue with 50% transparency

# we set duration, because by default image clip are infinite, and we cannot render infinite
txt_clip2 = txt_clip2.with_duration(2)
# ImageClip have no FPS either, so we must defined it
txt_clip1.write_videofile("result1.mp4", fps=24)
txt_clip2.write_videofile("result2.mp4", fps=24)


--- END moviepy/docs/_static/code/user_guide/loading/TextClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/ColorClip.py ---

from moviepy import ColorClip

# Color is passed as a RGB tuple
myclip = ColorClip(size=(200, 100), color=(255, 0, 0), duration=1)
# We really don't need more than 1 fps do we ?
myclip.write_videofile("result.mp4", fps=1)


--- END moviepy/docs/_static/code/user_guide/loading/ColorClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/closing.py ---

from moviepy import *

# clip.close() is implicitly called, so the lock on my_audiofile.mp3 file
# is immediately released.
try:
    with AudioFileClip("example.wav") as clip:
        raise Exception("Let's simulate an exception")
except Exception as e:
    print("{}".format(e))


--- END moviepy/docs/_static/code/user_guide/loading/closing.py ---



--- START moviepy/docs/_static/code/user_guide/loading/AudioArrayClip.py ---

"""Let's create an audioclip from values in a numpy array."""

import numpy as np
from moviepy import AudioArrayClip

# We want to play these notes
notes = {"A": 440, "B": 494, "C": 523, "D": 587, "E": 659, "F": 698}

note_duration = 0.5
total_duration = len(notes) * note_duration
sample_rate = 44100  # Number of samples per second

note_size = int(note_duration * sample_rate)
n_frames = note_size * len(notes)


def frame_function(t, note_frequency):
    return np.sin(note_frequency * 2 * np.pi * t)


# At this point one could use this audioclip which generates the audio on the fly
# clip = AudioFileClip(frame_function)

# We generate all frames timepoints

audio_frame_values = [
    2 * [frame_function(t, freq)]
    for freq in notes.values()
    for t in np.arange(0, note_duration, 1.0 / sample_rate)
]
# Create an AudioArrayClip from the audio samples
audio_clip = AudioArrayClip(np.array(audio_frame_values), fps=sample_rate)

# Write the audio clip to a WAV file
audio_clip.write_audiofile("result.wav", fps=44100)


--- END moviepy/docs/_static/code/user_guide/loading/AudioArrayClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/ImageClip.py ---

"""Here's how you transform a VideoClip into an ImageClip from an image, from
arbitrary data, or by extracting a frame at a given time"""

from moviepy import ImageClip, VideoFileClip
import numpy as np

# Random RGB noise image of 200x100
noise_image = np.random.randint(low=0, high=255, size=(100, 200, 3))

myclip1 = ImageClip("example.png")  # You can create it from a path
myclip2 = ImageClip(noise_image)  # from a (height x width x 3) RGB numpy array
# Or load videoclip and extract frame at a given time
myclip3 = VideoFileClip("./example.mp4").to_ImageClip(t="00:00:01")


--- END moviepy/docs/_static/code/user_guide/loading/ImageClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/AudioFileClip.py ---

from moviepy import *

# Works for audio files, but also videos file where you only want the keep the audio track
clip = AudioFileClip("example.wav")
clip.write_audiofile("./result.wav")


--- END moviepy/docs/_static/code/user_guide/loading/AudioFileClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/ImageSequenceClip.py ---

from moviepy import ImageSequenceClip

# A clip with a list of images showed for 1 second each
myclip = ImageSequenceClip(
    [
        "example_img_dir/image_0001.jpg",
        "example_img_dir/image_0002.jpg",
        "example_img_dir/image_0003.jpg",
    ],
    durations=[1, 1, 1],
)
# 3 images, 1 seconds each, duration = 3
print("Clip duration: {}".format(myclip.duration))
# 3 seconds, 3 images, fps is 3/3 = 1
print("Clip fps: {}".format(myclip.fps))

# This time we will load all images in the dir, and instead of showing theme
# for X seconds, we will define FPS
myclip2 = ImageSequenceClip("./example_img_dir", fps=30)
# fps = 30, so duration = nb images in dir / 30
print("Clip duration: {}".format(myclip2.duration))
print("Clip fps: {}".format(myclip2.fps))  # fps = 30

# the gif will be 30 fps, its duration will depend on the number of
# images in dir
myclip.write_gif("result.gif")  # the gif will be 3 sec and 1 fps
myclip2.write_gif("result2.gif")


--- END moviepy/docs/_static/code/user_guide/loading/ImageSequenceClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/AudioClip.py ---

from moviepy import AudioClip
import numpy as np


def audio_frame(t):
    """Producing a sinewave of 440 Hz -> note A"""
    return np.sin(440 * 2 * np.pi * t)


audio_clip = AudioClip(frame_function=audio_frame, duration=3)


--- END moviepy/docs/_static/code/user_guide/loading/AudioClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/VideoFileClip.py ---

from moviepy import VideoFileClip


myclip = VideoFileClip("example.mp4")

# video file clips already have fps and duration
print("Clip duration: {}".format(myclip.duration))
print("Clip fps: {}".format(myclip.fps))

myclip = myclip.subclipped(0.5, 2)  # Cutting the clip between 0.5 and 2 secs.
print("Clip duration: {}".format(myclip.duration))  # Cuting will update duration
print("Clip fps: {}".format(myclip.fps))  # and keep fps
# the output video will be 1.5 sec long and use original fps
myclip.write_videofile("result.mp4")


--- END moviepy/docs/_static/code/user_guide/loading/VideoFileClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/masks.py ---

import numpy as np

from moviepy import ImageClip, VideoClip, VideoFileClip


# Random RGB noise image of 200x100
frame_function = lambda t: np.random.rand(100, 200)

# To define the VideoClip as a mask, just pass parameter is_mask as True
maskclip1 = VideoClip(frame_function, duration=4, is_mask=True)  # A random noise mask
maskclip2 = ImageClip("example_mask.jpg", is_mask=True)  # A fixed mask as jpeg
maskclip3 = VideoFileClip("example_mask.mp4", is_mask=True)  # A video as a mask

# Load our basic clip, resize to 200x100 and apply each mask
clip = VideoFileClip("example.mp4")
clip_masked1 = clip.with_mask(maskclip1)
clip_masked2 = clip.with_mask(maskclip2)
clip_masked3 = clip.with_mask(maskclip3)


--- END moviepy/docs/_static/code/user_guide/loading/masks.py ---



--- START moviepy/docs/_static/code/user_guide/loading/VideoClip.py ---

import math

import numpy as np
from PIL import Image, ImageDraw

from moviepy import VideoClip


WIDTH, HEIGHT = (128, 128)
RED = (255, 0, 0)


def frame_function(t):
    frequency = 1  # One pulse per second
    coef = 0.5 * (1 + math.sin(2 * math.pi * frequency * t))  # radius varies over time
    radius = WIDTH * coef

    x1 = WIDTH / 2 - radius / 2
    y1 = HEIGHT / 2 - radius / 2
    x2 = WIDTH / 2 + radius / 2
    y2 = HEIGHT / 2 + radius / 2

    img = Image.new("RGB", (WIDTH, HEIGHT))
    draw = ImageDraw.Draw(img)
    draw.ellipse((x1, y1, x2, y2), fill=RED)

    return np.array(img)  # returns a 8-bit RGB array


# we define a 2s duration for the clip to be able to render it later
clip = VideoClip(frame_function, duration=2)
# we must set a framerate because VideoClip have no framerate by default
clip.write_gif("circle.gif", fps=15)


--- END moviepy/docs/_static/code/user_guide/loading/VideoClip.py ---



--- START moviepy/docs/_static/code/user_guide/loading/UpdatedVideoClip.py ---

import random

import numpy as np

from moviepy import UpdatedVideoClip


class CoinFlipWorld:
    """A simulation of coin flipping.

    Imagine we want to make a video that become more and more red as we repeat same face
    on coinflip in a row because coinflip are done in real time, we need to wait
    until a winning row is done to be able to make the next frame.
    This is a world simulating that. Sorry, it's hard to come up with examples...
    """

    def __init__(self, fps):
        """
        FPS is usefull because we must increment clip_t by 1/FPS to have
        UpdatedVideoClip run with a certain FPS
        """
        self.clip_t = 0
        self.win_strike = 0
        self.reset = False
        self.fps = fps

    def update(self):
        if self.reset:
            self.win_strike = 0
            self.reset = False

        print("strike : {}, clip_t : {}".format(self.win_strike, self.clip_t))
        print(self.win_strike)

        # 0 tails, 1 heads, this is our simulation of coinflip
        choice = random.randint(0, 1)
        face = random.randint(0, 1)

        # We win, we increment our serie and retry
        if choice == face:
            self.win_strike += 1
            return

        # Different face, we increment clip_t and set reset so we will reset on next update.
        # We don't reset immediately because we will need current state to make frame
        self.reset = True
        self.clip_t += 1 / self.fps

    def to_frame(self):
        """Return a frame of a 200x100 image with red more or less intense based
        on number of victories in a row."""
        red_intensity = 255 * (self.win_strike / 10)
        red_intensity = min(red_intensity, 255)

        # A 200x100 image with red more or less intense based on number of victories in a row
        return np.full((100, 200, 3), (red_intensity, 0, 0), dtype=np.uint8)


world = CoinFlipWorld(fps=5)

myclip = UpdatedVideoClip(world=world, duration=10)
# We will set FPS to same as world, if we was to use a different FPS,
# the lowest from world.fps and our write_videofile fps param
# will be the real visible fps
myclip.write_videofile("result.mp4", fps=5)


--- END moviepy/docs/_static/code/user_guide/loading/UpdatedVideoClip.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/concatenate.py ---

"""Let's concatenate (play one after the other) three video clips."""

from moviepy import VideoFileClip, concatenate_videoclips

# We load all the clips we want to concatenate
clip1 = VideoFileClip("example.mp4")
clip2 = VideoFileClip("example2.mp4").subclipped(0, 1)
clip3 = VideoFileClip("example3.mp4")

# We concatenate them and write the result
final_clip = concatenate_videoclips([clip1, clip2, clip3])
final_clip.write_videofile("final_clip.mp4")


--- END moviepy/docs/_static/code/user_guide/compositing/concatenate.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/juxtaposing.py ---

"""Let's juxtapose four video clips in a 2x2 grid."""

from moviepy import VideoFileClip, clips_array, vfx


# We will use the same clip and transform it in 3 ways
clip1 = VideoFileClip("example.mp4").with_effects([vfx.Margin(10)])  # add 10px contour
clip2 = clip1.with_effects([vfx.MirrorX()])  # Flip horizontaly
clip3 = clip1.with_effects([vfx.MirrorY()])  # Flip verticaly
clip4 = clip1.resized(0.6)  # downsize to 60% of original

# The form of the final clip will depend of the shape of the array
# We want our clip to be our 4 videos, 2x2, so we make an array of 2x2
array = [
    [clip1, clip2],
    [clip3, clip4],
]
final_clip = clips_array(array)
# let's resize the final clip so it has 480px of width
final_clip = final_clip.resized(width=480)

final_clip.write_videofile("final_clip.mp4")


--- END moviepy/docs/_static/code/user_guide/compositing/juxtaposing.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/CompositeAudioClip.py ---

"""Let's first concatenate (one after the other) then composite
(on top of each other) three audio clips."""

from moviepy import AudioFileClip, CompositeAudioClip, concatenate_audioclips

# We load all the clips we want to compose
clip1 = AudioFileClip("example.wav")
clip2 = AudioFileClip("example2.wav")
clip3 = AudioFileClip("example3.wav")

# All clip will play one after the other
concat = concatenate_audioclips([clip1, clip2, clip3])

# We will play clip1, then on top of it clip2 starting at t=5s,
# and clip3 on top of both starting t=9s
compo = CompositeAudioClip(
    [
        clip1.with_volume_scaled(1.2),
        clip2.with_start(5),  # start at t=5s
        clip3.with_start(9),
    ]
)


--- END moviepy/docs/_static/code/user_guide/compositing/CompositeAudioClip.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/with_position.py ---

"""Let's position some text and images on a video."""

from moviepy import CompositeVideoClip, ImageClip, TextClip, VideoFileClip


# We load all the clips we want to compose
background = VideoFileClip("example2.mp4").subclipped(0, 2)
title = TextClip(
    "./example.ttf",
    text="Big Buck Bunny",
    font_size=80,
    color="#fff",
    text_align="center",
    duration=1,
)
author = TextClip(
    "./example.ttf",
    text="Blender Foundation",
    font_size=40,
    color="#fff",
    text_align="center",
    duration=1,
)
copyright = TextClip(
    "./example.ttf",
    text="© CC BY 3.0",
    font_size=20,
    color="#fff",
    text_align="center",
    duration=1,
)
logo = ImageClip("./example2.png", duration=1).resized(height=50)

# We want our title to be at the center horizontaly and start at 25%
# of the video verticaly. We can set as "center", "left", "right",
# "top" and "bottom", and % relative from the clip size
title = title.with_position(("center", 0.25), relative=True)

# We want the author to be in the center, 30px under the title
# We can set as pixels
top = background.h * 0.25 + title.h + 30
left = (background.w - author.w) / 2
author = author.with_position((left, top))

# We want the copyright to be 30px before bottom
copyright = copyright.with_position(("center", background.h - copyright.h - 30))

# Finally, we want the logo to be in the center, but to drop as time pass
# We can do so by setting position as a function that take time as argument,
# a lot like frame_function
top = (background.h - logo.h) / 2
logo = logo.with_position(lambda t: ("center", top + t * 30))

# We write the result
final_clip = CompositeVideoClip([background, title, author, copyright, logo])
final_clip.write_videofile("final_clip.mp4")


--- END moviepy/docs/_static/code/user_guide/compositing/with_position.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/CompositeVideoClip.py ---

"""Let's stack three video clips on top of each other with
CompositeVideoClip."""

from moviepy import VideoFileClip, CompositeVideoClip

# We load all the clips we want to compose
clip1 = VideoFileClip("example.mp4")
clip2 = VideoFileClip("example2.mp4").subclipped(0, 1)
clip3 = VideoFileClip("example.mp4")

# We concatenate them and write theme stacked on top of each other,
# with clip3 over clip2 over clip1
final_clip = CompositeVideoClip([clip1, clip2, clip3])
final_clip.write_videofile("final_clip.mp4")


--- END moviepy/docs/_static/code/user_guide/compositing/CompositeVideoClip.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/crossfadein.py ---

"""In this example, we will concatenate two clips with a 1-second
crossfadein of the second clip."""

from moviepy import VideoFileClip, CompositeVideoClip, vfx

# We load all the clips we want to compose
clip1 = VideoFileClip("example.mp4")
clip2 = VideoFileClip("example2.mp4")

clips = [
    clip1.with_end(2),
    clip2.with_start(1).with_effects([vfx.CrossFadeIn(1)]),
]
final_clip = CompositeVideoClip(clips)
final_clip.write_videofile("final_clip.mp4")


--- END moviepy/docs/_static/code/user_guide/compositing/crossfadein.py ---



--- START moviepy/docs/_static/code/user_guide/compositing/with_start.py ---

from moviepy import VideoFileClip, CompositeVideoClip

# We load all the clips we want to compose
clip1 = VideoFileClip("example.mp4")
clip2 = VideoFileClip("example2.mp4").subclipped(0, 1)
clip3 = VideoFileClip("example3.mp4")

# We want to stop clip1 after 1s
clip1 = clip1.with_end(1)

# We want to play clip2 after 1.5s
clip2 = clip2.with_start(1.5)

# We want to play clip3 at the end of clip2, and so for 3 seconds only
# Some times its more practical to modify the duration of a clip instead
# of his end
clip3 = clip3.with_start(clip2.end).with_duration(1)

# We write the result
final_clip = CompositeVideoClip([clip1, clip2, clip3])
final_clip.write_videofile("final_clip.mp4")


--- END moviepy/docs/_static/code/user_guide/compositing/with_start.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/preview.py ---

from moviepy import *


myclip = VideoFileClip("./example.mp4").subclipped(0, 1)  # Keep only 0 to 1 sec

# We preview our clip as a video, inheriting FPS and audio of the original clip
myclip.preview()

# We preview our clip as video, but with a custom FPS for video and audio
# making it less consuming for our computer
myclip.preview(fps=5, audio_fps=11000)

# Now we preview without audio
myclip.preview(audio=False)


--- END moviepy/docs/_static/code/user_guide/rendering/preview.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/show.py ---

from moviepy import *

myclip = VideoFileClip("./example.mp4")

# We show the first frame of our clip
myclip.show()

# We show the frame at point 00:00:01.5 of our clip
myclip.show(1.5)

# We want to see our clip without applying his mask
myclip.show(1.5, with_mask=False)


--- END moviepy/docs/_static/code/user_guide/rendering/show.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/save_frame.py ---

from moviepy import *

# We load all the clips we want to compose
myclip = VideoFileClip("example.mp4")
myclip.save_frame("result.png", t=1)  # Save frame at 1 sec


--- END moviepy/docs/_static/code/user_guide/rendering/save_frame.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/write_videofile_duration.py ---

from moviepy import *

# By default an ImageClip has no duration
my_clip = ImageClip("example.png")

try:
    # This will fail! We cannot write a clip with no duration!
    my_clip.write_videofile("result.mp4")
except:
    print("Cannot write a video without duration")

# By calling with_duration on our clip, we fix the problem! We also need to set fps
my_clip.with_duration(2).write_videofile("result.mp4", fps=1)


--- END moviepy/docs/_static/code/user_guide/rendering/write_videofile_duration.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/write_gif.py ---

from moviepy import *

myclip = VideoFileClip("example.mp4").subclipped(0, 2)

# Here we just save as GIF
myclip.write_gif("result.gif")

# Here we save as GIF, but we set the FPS of our GIF at 10
myclip.write_gif("result.gif", fps=10)


--- END moviepy/docs/_static/code/user_guide/rendering/write_gif.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/display_in_notebook.py ---

from moviepy import *

# ...
# ... some jupyter specifics stuff
# ...

my_video_clip = VideoFileClip("./example.mp4")
my_image_clip = ImageClip("./example.png")
my_audio_clip = AudioFileClip("./example.wav")

# We can show any type of clip
my_video_clip.display_in_notebook()  # embeds a video
my_image_clip.display_in_notebook()  # embeds an image
my_audio_clip.display_in_notebook()  # embeds a sound

# We can display only a snaphot of a video
my_video_clip.display_in_notebook(t=1)

# We can provide any valid HTML5 option as keyword argument
# For instance, if the clip is too big, we can set width
my_video_clip.display_in_notebook(width=400)

# We can also make it loop, for example to check if a GIF is
# looping as expected
my_video_clip.display_in_notebook(autoplay=1, loop=1)


--- END moviepy/docs/_static/code/user_guide/rendering/display_in_notebook.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/write_videofile.py ---

from moviepy import *

# We load all the clips we want to compose
background = VideoFileClip("long_examples/example2.mp4").subclipped(0, 10)
title = TextClip(
    "./example.ttf",
    text="Big Buck Bunny",
    font_size=80,
    color="#fff",
    text_align="center",
    duration=3,
).with_position(("center", "center"))

# We make our final clip through composition
final_clip = CompositeVideoClip([background, title])

# And finally we can write the result into a file

# Here we just save as MP4, inheriting FPS, etc. from final_clip
final_clip.write_videofile("result.mp4")

# Here we save as MP4, but we set the FPS of the clip to our own, here 24 fps, like cinema
final_clip.write_videofile("result24fps.mp4", fps=24)

# Now we save as WEBM instead, and we want tu use codec libvpx-vp9 (usefull when mp4 + transparency).
# We also want ffmpeg compression optimisation as minimal as possible. This will not change
# the video quality and it will decrease time for encoding, but increase final file size a lot.
# Finally, we want ffmpeg to use 4 threads for video encoding. You should probably leave that
# to default, as ffmpeg is already quite good at using the best setting on his own.
final_clip.write_videofile(
    "result.webm", codec="libvpx-vp9", fps=24, preset="ultrafast", threads=4
)


--- END moviepy/docs/_static/code/user_guide/rendering/write_videofile.py ---



--- START moviepy/docs/_static/code/user_guide/rendering/write_images_sequence.py ---

from moviepy import *
import os

myclip = VideoFileClip("example.mp4")

# Here we just save in dir output with filename being his index (start at 0, then +1 for each frame)
os.mkdir("./output")
myclip.write_images_sequence("./output/%d.jpg")

# We set the FPS of our GIF at 10, and we leftpad name with 0 up to 4 digits
myclip.write_images_sequence("./output/%04d.jpg")


--- END moviepy/docs/_static/code/user_guide/rendering/write_images_sequence.py ---



--- START moviepy/docs/_static/code/user_guide/effects/using_effects.py ---

from moviepy import VideoFileClip
from moviepy import vfx, afx

myclip = VideoFileClip("example.mp4")
# resize clip to be 460px in width, keeping aspect ratio
myclip = myclip.with_effects([vfx.Resize(width=460)])

# fx method return a copy of the clip, so we can easily chain them
# double the speed and half the audio volume
myclip = myclip.with_effects([vfx.MultiplySpeed(2), afx.MultiplyVolume(0.5)])

# because effects are added to Clip at runtime, you can also call
# them directly from your clip as methods
myclip = myclip.with_effects([vfx.MultiplyColor(0.5)])  # darken the clip


--- END moviepy/docs/_static/code/user_guide/effects/using_effects.py ---



--- START moviepy/docs/_static/code/user_guide/effects/modify_copy_example.py ---

# Import everything needed to edit video clips
from moviepy import VideoFileClip

# Load example.mp4
clip = VideoFileClip("example.mp4")

# This does nothing, as multiply_volume will return a copy of clip
# which you will loose immediatly as you don't store it
# If you was to render clip now, the audio would still be at full volume
clip.with_volume_scaled(0.1)

# This create a copy of clip in clip_whisper with a volume of only 10% the original,
# but does not modify the original clip
# If you was to render clip right now, the audio would still be at full volume
# If you was to render clip_whisper, the audio would be a 10% of the original volume
clip_whisper = clip.with_volume_scaled(0.1)

# This replace the original clip with a copy of it where volume is only 10% of
# the original. If you was to render clip now, the audio would be at 10%
# The original clip is now lost
clip = clip.with_volume_scaled(0.1)


--- END moviepy/docs/_static/code/user_guide/effects/modify_copy_example.py ---



--- START moviepy/docs/_static/code/user_guide/effects/custom_effect.py ---

"""Let's write a custom effect that will add a basic progress bar
at the bottom of our clip."""

from moviepy import VideoClip
from moviepy.decorators import requires_duration


# Here you see a decorator that will verify if our clip have a duration
# MoviePy offer a few of them that may come handy when writing your own effects
@requires_duration
def progress_bar(clip: VideoClip, color: tuple, height: int = 10):
    """
    Add a progress bar at the bottom of our clip

     Parameters
    ----------

      color: Color of the bar as a RGB tuple
      height: The height of the bar in pixels. Default = 10
    """

    # Because we have define the filter func inside our global effect,
    # it have access to global effect scope and can use clip from inside filter
    def filter(get_frame, t):
        progression = t / clip.duration
        bar_width = int(progression * clip.w)

        # Showing a progress bar is just replacing bottom pixels
        # on some part of our frame
        frame = get_frame(t)
        frame[-height:, 0:bar_width] = color

        return frame

    return clip.transform(filter, apply_to="mask")


--- END moviepy/docs/_static/code/user_guide/effects/custom_effect.py ---



--- START moviepy/docs/_static/code/user_guide/effects/time_transform.py ---

from moviepy import VideoFileClip
import math

my_clip = VideoFileClip("example.mp4")

# Let's accelerate the video by a factor of 3
modified_clip1 = my_clip.time_transform(lambda t: t * 3)
# Let's play the video back and forth with a "sine" time-warping effect
modified_clip2 = my_clip.time_transform(lambda t: 1 + math.sin(t))


--- END moviepy/docs/_static/code/user_guide/effects/time_transform.py ---



--- START moviepy/docs/_static/code/user_guide/effects/using_with_methods.py ---

from moviepy import VideoFileClip

myclip = VideoFileClip("example.mp4")
myclip = myclip.with_end(5)  # stop the clip after 5 sec
myclip = myclip.without_audio()  # remove the audio of the clip


--- END moviepy/docs/_static/code/user_guide/effects/using_with_methods.py ---



--- START moviepy/docs/_static/code/user_guide/effects/transform.py ---

"""Let's create a scolling video effect from scratch."""

from moviepy import VideoFileClip

my_clip = VideoFileClip("example.mp4")


def scroll(get_frame, t):
    """
    This function returns a 'region' of the current frame.
    The position of this region depends on the time.
    """
    frame = get_frame(t)
    frame_region = frame[int(t) : int(t) + 360, :]
    return frame_region


modified_clip1 = my_clip.transform(scroll)


--- END moviepy/docs/_static/code/user_guide/effects/transform.py ---



--- START moviepy/docs/_static/code/user_guide/effects/image_transform.py ---

"""Let's invert the green and blue channels of a video."""

from moviepy import VideoFileClip
import numpy

my_clip = VideoFileClip("example.mp4")


def invert_green_blue(image: numpy.ndarray) -> numpy.ndarray:
    return image[:, :, [0, 2, 1]]


modified_clip1 = my_clip.image_transform(invert_green_blue)


--- END moviepy/docs/_static/code/user_guide/effects/image_transform.py ---



--- START moviepy/docs/_static/code/getting_started/moviepy_10_minutes/trailer.py ---

# Lets import moviepy, lets also import numpy we will use it a some point
import numpy as np

from moviepy import *


#################
# VIDEO LOADING #
#################
# We load our video
video = VideoFileClip("./resources/bbb.mp4")


#####################
# SCENES EXTRACTION #
#####################
# We extract the scenes we want to use

# First the characters
intro_clip = video.subclipped(1, 11)
bird_clip = video.subclipped(16, 20)
bunny_clip = video.subclipped(37, 55)
rodents_clip = video.subclipped(
    "00:03:34.75", "00:03:56"
)  # we can also use string notation with format HH:MM:SS.uS
rambo_clip = video.subclipped("04:41.5", "04:44.70")


#####################
# SCENES PREVIEWING #
#####################
# Now, lets have a first look at our clips
# Warning: you need ffplay installed for preview to work
# We set a low fps so our machine can render in real time without slowing down
intro_clip.preview(fps=20)
bird_clip.preview(fps=20)
bunny_clip.preview(fps=20)
rodents_clip.preview(fps=20)
rambo_clip.preview(fps=20)


##############################
# CLIPS MODIFICATION CUTTING #
##############################
# Well, looking at the rodent scene it is a bit long isn't?
# Let's see how we modify the clip with one of the many clip manipulation method starting by with_*
# in that case by removing of the clip the part between 00:06:00 to 00:10:00 of the clip, using with_section_cut_out
rodents_clip = rodents_clip.with_section_cut_out(start_time=4, end_time=10)

# Note: You may have noticed that we have reassign rodents_clip, this is because all with_* methods return a modified *copy* of the
# original clip instead of modifying it directly. In MoviePy any function starting by with_* is out-place instead of in-place
# meaning it does not modify the original data, but instead copy it and modify/return the copy

# Lets check the result
rodents_clip.preview(fps=10)

############################
# TEXT/LOGO CLIPS CREATION #
############################
# Lets create the texts to put between our clips
font = "./resources/font/font.ttf"
intro_text = TextClip(
    font=font,
    text="The Blender Foundation and\nPeach Project presents",
    font_size=50,
    color="#fff",
    text_align="center",
)
bird_text = TextClip(font=font, text="An unlucky bird", font_size=50, color="#fff")
bunny_text = TextClip(
    font=font, text="A (slightly overweight) bunny", font_size=50, color="#fff"
)
rodents_text = TextClip(
    font=font, text="And three rodent pests", font_size=50, color="#fff"
)
revenge_text = TextClip(
    font=font, text="Revenge is coming...", font_size=50, color="#fff"
)
made_with_text = TextClip(font=font, text="Made with", font_size=50, color="#fff")

# We will also need the big buck bunny logo, so lets load it and resize it
logo_clip = ImageClip("./resources/logo_bbb.png").resized(width=400)
moviepy_clip = ImageClip("./resources/logo_moviepy.png").resized(width=300)


################
# CLIPS TIMING #
################
# We have all the clips we need, but if we was to turn all the clips into a single one with composition (we will see that during next step)
# all our clips would start at the same time and play on top of each other, which is obviously not what we want.
# To fix that, we need to say when a clip should start and stop in the final clip.
# So, lets start by telling when each clip must start and end with appropriate with_* methods
intro_text = intro_text.with_duration(6).with_start(
    3
)  # Intro for 6 seconds, start after 3 seconds
logo_clip = logo_clip.with_start(intro_text.start + 2).with_end(
    intro_text.end
)  # Logo start 2 second after intro text and stop with it
bird_clip = bird_clip.with_start(
    intro_clip.end
)  # Make bird clip start after intro, duration already known
bird_text = bird_text.with_start(bird_clip.start).with_end(
    bird_clip.end
)  # Make text synchro with clip
bunny_clip = bunny_clip.with_start(bird_clip.end)  # Make bunny clip follow bird clip
bunny_text = bunny_text.with_start(bunny_clip.start + 2).with_duration(7)
rodents_clip = rodents_clip.with_start(bunny_clip.end)
rodents_text = rodents_text.with_start(rodents_clip.start).with_duration(4)
rambo_clip = rambo_clip.with_start(rodents_clip.end - 1.5)
revenge_text = revenge_text.with_start(rambo_clip.start + 1.5).with_duration(4)
made_with_text = made_with_text.with_start(rambo_clip.end).with_duration(3)
moviepy_clip = moviepy_clip.with_start(made_with_text.start).with_duration(3)


########################
# CLIPS TIMING PREVIEW #
########################
# Lets make a first compositing of the clips into one single clip and do a quick preview to see if everything is synchro

quick_compo = CompositeVideoClip(
    [
        intro_clip,
        intro_text,
        logo_clip,
        bird_clip,
        bird_text,
        bunny_clip,
        bunny_text,
        rodents_clip,
        rodents_text,
        rambo_clip,
        revenge_text,
        made_with_text,
        moviepy_clip,
    ]
)
quick_compo.preview(fps=10)


######################
# CLIPS POSITIONNING #
######################
# Now that we have set the timing of our different clips, we need to make sure they are in the right position
# We will keep things simple, and almost always set center center for every texts
bird_text = bird_text.with_position(("center", "center"))
bunny_text = bunny_text.with_position(("center", "center"))
rodents_text = rodents_text.with_position(("center", "center"))
revenge_text = revenge_text.with_position(("center", "center"))

# For the logos and intro/end, we will use pixel position instead of center
top = intro_clip.h // 2
intro_text = intro_text.with_position(("center", 200))
logo_clip = logo_clip.with_position(("center", top))
made_with_text = made_with_text.with_position(("center", 300))
moviepy_clip = moviepy_clip.with_position(("center", 360))

# Lets take another look to check positions
quick_compo = CompositeVideoClip(
    [
        intro_clip,
        intro_text,
        logo_clip,
        bird_clip,
        bird_text,
        bunny_clip,
        bunny_text,
        rodents_clip,
        rodents_text,
        rambo_clip,
        revenge_text,
        made_with_text,
        moviepy_clip,
    ]
)
quick_compo.preview(fps=10)


################################
# CLIPS TRANSITION AND EFFECTS #
################################
# Now that our clip are timed and positionned, lets add some transition to make it more natural
# To do so we use the with_effects method and the video effects in vfx
# We call with_effects on our clip and pass it an array of effect objects to apply
# We'll keep it simple, nothing fancy just cross fading
intro_text = intro_text.with_effects([vfx.CrossFadeIn(1), vfx.CrossFadeOut(1)])
logo_clip = logo_clip.with_effects([vfx.CrossFadeIn(1), vfx.CrossFadeOut(1)])
bird_text = bird_text.with_effects([vfx.CrossFadeIn(0.5), vfx.CrossFadeOut(0.5)])
bunny_text = bunny_text.with_effects([vfx.CrossFadeIn(0.5), vfx.CrossFadeOut(0.5)])
rodents_text = rodents_text.with_effects([vfx.CrossFadeIn(0.5), vfx.CrossFadeOut(0.5)])

# Also add cross fading on video clips and video clips audio
# See how video effects are under vfx and audio ones under afx
intro_clip = intro_clip.with_effects(
    [vfx.FadeIn(1), vfx.FadeOut(1), afx.AudioFadeIn(1), afx.AudioFadeOut(1)]
)
bird_clip = bird_clip.with_effects(
    [vfx.FadeIn(1), vfx.FadeOut(1), afx.AudioFadeIn(1), afx.AudioFadeOut(1)]
)
bunny_clip = bunny_clip.with_effects(
    [vfx.FadeIn(1), vfx.FadeOut(1), afx.AudioFadeIn(1), afx.AudioFadeOut(1)]
)
rodents_clip = rodents_clip.with_effects(
    [
        vfx.FadeIn(1),
        vfx.CrossFadeOut(1.5),
        afx.AudioFadeIn(1),
        afx.AudioFadeOut(1.5),
    ]
)  # Just fade in, rambo clip will do the cross fade
rambo_clip = rambo_clip.with_effects(
    [
        vfx.CrossFadeIn(1.5),
        vfx.FadeOut(1),
        afx.AudioFadeIn(1.5),
        afx.AudioFadeOut(1),
    ]
)
rambo_clip = rambo_clip.with_effects(
    [
        vfx.CrossFadeIn(1.5),
        vfx.FadeOut(1),
        afx.AudioFadeIn(1.5),
        afx.AudioFadeOut(1),
    ]
)

# Effects are not only for transition, they can also change a clip timing or appearance
# To show that, lets also modify the Rambo-like part of our clip to be in slow motion
# PS: We do it for effect, but this is one of the few effects that have a direct shortcut, with_speed_scaled
# the others are with_volume_scaled, resized, cropped and rotated
rambo_clip = rambo_clip.with_effects([vfx.MultiplySpeed(0.5)])

# Because we modified timing of rambo_clip with our MultiplySpeed effect, we must re-assign the following clips timing
made_with_text = made_with_text.with_start(rambo_clip.end).with_duration(3)
moviepy_clip = moviepy_clip.with_start(made_with_text.start).with_duration(3)

# Let's have a last look at the result to make sure everything is working as expected
quick_comp = CompositeVideoClip(
    [
        intro_clip,
        intro_text,
        logo_clip,
        bird_clip,
        bird_text,
        bunny_clip,
        bunny_text,
        rodents_clip,
        rodents_text,
        rambo_clip,
        revenge_text,
        made_with_text,
        moviepy_clip,
    ]
)
quick_comp.preview(fps=10)


###############
# CLIP FILTER #
###############
# Lets finish by modifying our rambo clip to make it sepia


# We will start by defining a function that turn a numpy image into sepia
# It takes the image as numpy array in entry and return the modified image as output
def sepia_filter(frame: np.ndarray):
    # Sepia filter transformation matrix
    # Sepia transform works by applying to each pixel of the image the following rules
    # res_R = (R * .393) + (G *.769) + (B * .189)
    # res_G = (R * .349) + (G *.686) + (B * .168)
    # res_B = (R * .272) + (G *.534) + (B * .131)
    #
    # With numpy we can do that very efficiently by multiplying the image matrix by a transformation matrix
    sepia_matrix = np.array(
        [[0.393, 0.769, 0.189], [0.349, 0.686, 0.168], [0.272, 0.534, 0.131]]
    )

    # Convert the image to float32 format for matrix multiplication
    frame = frame.astype(np.float32)

    # Apply the sepia transformation
    # .T is needed because multiplying matrix of shape (n,m) * (m,k) result in a matrix of shape (n,k)
    # what we want is (n,m), so we must transpose matrix (m,k) to (k,m)
    sepia_image = np.dot(frame, sepia_matrix.T)

    # Because final result can be > 255, we limit the result to range [0, 255]
    sepia_image = np.clip(sepia_image, 0, 255)

    # Convert the image back to uint8 format, because we need integer not float
    sepia_image = sepia_image.astype(np.uint8)

    return sepia_image


# Now, we simply apply the filter to our clip by calling image_transform, which will call our filter on every frame
rambo_clip = rambo_clip.image_transform(sepia_filter)

# Let's see how our filter look
rambo_clip.preview(fps=10)


##################
# CLIP RENDERING #
##################
# Everything is good and ready, we can finally render our clip into a file
final_clip = CompositeVideoClip(
    [
        intro_clip,
        intro_text,
        logo_clip,
        bird_clip,
        bird_text,
        bunny_clip,
        bunny_text,
        rodents_clip,
        rodents_text,
        rambo_clip,
        revenge_text,
        made_with_text,
        moviepy_clip,
    ]
)
final_clip.write_videofile("./result.mp4")


--- END moviepy/docs/_static/code/getting_started/moviepy_10_minutes/trailer.py ---



--- START moviepy/docs/_static/code/getting_started/quick_presentation/basic_example.py ---

# Import everything needed to edit video clips
from moviepy import *

# Load file example.mp4 and extract only the subclip from 00:00:10 to 00:00:20
clip = VideoFileClip("long_examples/example2.mp4").subclipped(10, 20)

# Reduce the audio volume to 80% of his original volume
clip = clip.with_volume_scaled(0.8)

# Generate a text clip. You can customize the font, color, etc.
txt_clip = TextClip(
    font="example.ttf", text="Big Buck Bunny", font_size=70, color="white"
)

# Say that you want it to appear for 10s at the center of the screen
txt_clip = txt_clip.with_position("center").with_duration(10)

# Overlay the text clip on the first video clip
video = CompositeVideoClip([clip, txt_clip])

# Write the result to a file (many options available!)
video.write_videofile("result.mp4")


--- END moviepy/docs/_static/code/getting_started/quick_presentation/basic_example.py ---



--- START moviepy/docs/developer_guide/index.rst ---

.. _developer_guide:

The MoviePy Developer's Guide
-----------------------------

This guide covers most of the things people wanting to participate in MoviePy development need to know.

.. toctree::
   :maxdepth: 1
   
   developers_install
   contribution_guidelines
   maintainers_publish


--- END moviepy/docs/developer_guide/index.rst ---



--- START moviepy/docs/developer_guide/contribution_guidelines.rst ---

.. _contribution_guidelines:

MoviePy's Contribution Guidelines
=================================

Communication on GitHub
-----------------------

- Keep messages on GitHub issues and pull requests on-topic and to the point. Be aware that each comment triggers a notification which gets sent out to a number of people.
    - Opinions are OK.
    - For longer or more in-depth discussions, use the `MoviePy Gitter <https://gitter.im/Movie-py>`_. If these discussions lead to a decision, like a merge/reject, please leave a message on the relevant MoviePy issue to document the outcome of the discussion/the reason for the decision.
- Do not push any commit that changes the API without prior discussion.

Preparing for development
-------------------------

- Fork the official MoviePy repository to your own GitHub account:  
  Use the "Fork" button in the top right corner of the GitHub interface while viewing `the official MoviePy <https://github.com/Zulko/moviepy>`_ repository.
- Use your fork as the basis for cloning the repository to your local machine: ``$ git clone URL_TO_YOUR_FORK``  
  You can get the appropriate URL (SSH- or HTTPS-based) by using the green "Code" button located at the top right of the repository view while looking at your fork. By default, Git refers to any remote you clone from – i.e. in this case your fork on GitHub – as ``origin``.
- Enter your local clone and add the official MoviePy repository as a second remote, with alias ``upstream``:  
  ``$ git remote add upstream git@github.com:Zulko/moviepy.git`` (using SSL) _or_   
  ``$ git remote add upstream https://github.com/Zulko/moviepy.git`` (using HTTPS).
- Install the library inside a `virtual environment <https://docs.python.org/3/tutorial/venv.html>`_ with all dependencies included using ``$ pip install -e ".[optional,doc,test,lint]"``
- Configure pre-commit hooks running ``$ pre-commit install``

Coding conventions, code quality
--------------------------------

- Respect `PEP8 <https://www.python.org/dev/peps/pep-0008/>`_ conventions.
- Add just the "right" amount of comments. Try to write auto-documented code with very explicit variable names.
- If you introduce new functionality or fix a bug, document it in the docstring or with code comments.
- MoviePy's team adopted `pre-commit <https://pre-commit.com/>`_ to run code checks using black, flake8 and isort, so make sure that you've configured the pre-commit hooks with ``pre-commit install``. 

Standard contribution workflow
------------------------------

Local development
~~~~~~~~~~~~~~~~~

- Keep your local ``master`` branch up-to-date with the official repo's master by periodically fetching/pulling it:  
  ``$ git pull upstream master``
- Never make changes on ``master`` directly, but branch off into separate develop branches:  
  ``$ git checkout --branch YOUR_DEVELOP_BRANCH``  
  Ideally, these are given names which function as keywords for what you are working on, and are prefixed with ``fix_`` (for bug fixes), ``feature_`` or something similarly appropriate and descriptive.
- Base any changes you submit on the most recent ``master``.

More detailed explanation of the last point:

It is likely that the official repo's ``master`` branch will move on (get updated, have other PRs merged into it) while you are working on your changes. Before creating a pull request, you will have to make sure your changes are not based on outdated code. For this reason, it makes sense to avoid falling "too much behind" while developing by rebasing your local ``master`` branch at intervals. Make sure your ``master`` branch is in sync with the official ``master`` branch (as per the first point), then, while checked into your develop branch, run: ``$ git rebase master``

If you **haven't rebased before**, make sure to **familiarise yourself** with the concept.

Submitting Pull Requests
~~~~~~~~~~~~~~~~~~~~~~~~

You do not have to have finished your feature or bug fix before submitting a PR; just mention that it still is a work in progress.

Before submitting PRs:

- run the test suite over your code to expose any problems: ``$ pytest``
- push your local develop branch to your GitHub fork ``$ git push origin YOUR_DEVELOP_BRANCH``

When you now look at your forked repo on your GitHub account, you will see GitHub suggest branches for sending pull requests to the official ``Zulko/moviepy`` repository.

Once you open a PR, you will be presented with a template which you are asked to fill out. You are encouraged to add any additional information which helps provide further context to your changes, and to link to any issues or PRs which your pull request references or is informed by.

On submitting your PR, an automated test suite runs over your submission, which might take a few minutes to complete. In a next step, a MoviePy maintainer will review your code and, if necessary, help you to get it merge-ready.


--- END moviepy/docs/developer_guide/contribution_guidelines.rst ---



--- START moviepy/docs/developer_guide/developers_install.rst ---

.. _developers_install:

Installation for MoviePy developers
======================================

.. warning::
    This part is only destined to people who want to build the MoviePy documentation by themselves, or to contribute to MoviePy. Normal users don't need it.

In addition to MoviePy main libraries, MoviePy developers will also need to install additional libraries to be able to run MoviePy tests and build the MoviePy documentation.

Libraries for documentation
-----------------------------

You can install the libraries required to build documentation with: 

.. code:: bash

    $ (sudo) pip install moviepy[doc]

Once libraries installed you can build the documentation with:

.. code:: bash

    $ python setup.py build_docs


Libraries for testing and linting
-------------------------------------

You can install the libraries required for testing and linting with:

.. code:: bash

    $ (sudo) pip install moviepy[test]
    $ (sudo) pip install moviepy[lint]

Once libraries installed you can test with:

.. code:: bash

    $ python -m pytest

And you can lint with:

.. code:: bash

    $ python -m black .

and 

.. code:: bash

    $ python3 -m flake8 -v --show-source --ignore=E501 moviepy docs/conf.py examples tests

Adding Git pre-commit hooks
-----------------------------

Running linter manually is painfull and error prone, instead you should consider adding a pre-commit hook.
To do so you can simply go in your local moviepy directory, and run :

.. code:: bash
    $ pre-commit install

This will enable a git hooks using python pre-commit framework.





--- END moviepy/docs/developer_guide/developers_install.rst ---



--- START moviepy/docs/developer_guide/maintainers_publish.rst ---

.. _maintainers_publish:

Publishing a New Version of MoviePy
===================================

This section is for maintainers responsible for publishing new versions of MoviePy. Follow these steps to ensure the process is smooth and consistent:

**Pre-requisites**
------------------
- Ensure you have proper permissions to push changes and create releases in the MoviePy repository.

Steps to Publish a New Version
------------------------------

1. **Update the `CHANGELOG.md`**

   - Add a new section for the upcoming version, respecting the format used in previous entries.
   - Summarize all changes, fixes, and new features.

2. **Update the version in `pyproject.toml`**

   - Open the `pyproject.toml` file.
   - Update the `version` field to the new version, following `Semantic Versioning <https://semver.org/>`_.

3. **Commit and Push**

   - Stage your changes::

        git add CHANGELOG.md pyproject.toml

   - Commit your changes::

        git commit -m "Release vX.Y.Z"

   - Push your changes::

        git push

4. **Create a New Tag**

   - Create a tag for the new version (replace ``vX.Y.Z`` with the actual version number)::

        git tag -a vX.Y.Z -m "Release vX.Y.Z"

   - Push the tag to the remote repository::

        git push origin vX.Y.Z

5. **Create a New Release**

   - Go to the repository's page on GitHub (or the relevant hosting platform).
   - Navigate to the "Releases" section and create a new release.
   - Use the new tag (``vX.Y.Z``) and provide a description for the release.
     - Copy the changelog for this version into the release description.
   - Publish the release.

GitHub actions will automatically build and publish the new release on PyPi.

By following these steps, you ensure that each MoviePy release is well-documented, correctly versioned, and accessible to users.


--- END moviepy/docs/developer_guide/maintainers_publish.rst ---



--- START moviepy/docs/reference/index.rst ---

.. _reference_manual:


Api Reference
================

This is the definitive place to find all the details on MoviePy API documentation.

For a more beginner introduction, please see :ref:`getting_started`, for a more detailed explanations of the different concepts in MoviePy,
see :ref:`user_guide`.

.. autosummary::
   :toctree: reference
   :recursive:
   :template: custom_autosummary/module.rst

   moviepy



--- END moviepy/docs/reference/index.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.FadeOut.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.FadeOut
========================

 
.. automodule:: moviepy.video.fx.FadeOut
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.FadeOut.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.ImageClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.ImageClip
=================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: ImageClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.ImageClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.gif_writers.write_gif_with_imageio.rst ---

moviepy.video.io.gif\_writers.write\_gif\_with\_imageio
=======================================================

.. currentmodule:: moviepy.video.io.gif_writers

.. autofunction:: write_gif_with_imageio

--- END moviepy/docs/reference/reference/moviepy.video.io.gif_writers.write_gif_with_imageio.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.FreezeRegion.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.FreezeRegion
=============================

 
.. automodule:: moviepy.video.fx.FreezeRegion
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.FreezeRegion.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.tools.cuts.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.tools.cuts
========================


.. automodule:: moviepy.audio.tools.cuts

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      find_audio_period
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.tools.cuts.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.UpdatedVideoClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.UpdatedVideoClip
========================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: UpdatedVideoClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.UpdatedVideoClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx
================


.. automodule:: moviepy.video.fx

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.video.fx.AccelDecel


   moviepy.video.fx.BlackAndWhite


   moviepy.video.fx.Blink


   moviepy.video.fx.Crop


   moviepy.video.fx.CrossFadeIn


   moviepy.video.fx.CrossFadeOut


   moviepy.video.fx.EvenSize


   moviepy.video.fx.FadeIn


   moviepy.video.fx.FadeOut


   moviepy.video.fx.Freeze


   moviepy.video.fx.FreezeRegion


   moviepy.video.fx.GammaCorrection


   moviepy.video.fx.HeadBlur


   moviepy.video.fx.InvertColors


   moviepy.video.fx.Loop


   moviepy.video.fx.LumContrast


   moviepy.video.fx.MakeLoopable


   moviepy.video.fx.Margin


   moviepy.video.fx.MaskColor


   moviepy.video.fx.MasksAnd


   moviepy.video.fx.MasksOr


   moviepy.video.fx.MirrorX


   moviepy.video.fx.MirrorY


   moviepy.video.fx.MultiplyColor


   moviepy.video.fx.MultiplySpeed


   moviepy.video.fx.Painting


   moviepy.video.fx.Resize


   moviepy.video.fx.Rotate


   moviepy.video.fx.Scroll


   moviepy.video.fx.SlideIn


   moviepy.video.fx.SlideOut


   moviepy.video.fx.SuperSample


   moviepy.video.fx.TimeMirror


   moviepy.video.fx.TimeSymmetrize




--- END moviepy/docs/reference/reference/moviepy.video.fx.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.credits.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.tools.credits
===========================


.. automodule:: moviepy.video.tools.credits

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      CreditsClip
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.tools.credits.rst ---



--- START moviepy/docs/reference/reference/moviepy.Clip.Clip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.Clip.Clip
=================

.. currentmodule:: moviepy.Clip

.. autoclass:: Clip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.Clip.Clip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.FFMPEG_VideoReader.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.ffmpeg\_reader.FFMPEG\_VideoReader
===================================================

.. currentmodule:: moviepy.video.io.ffmpeg_reader

.. autoclass:: FFMPEG_VideoReader
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.FFMPEG_VideoReader.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.clips_array.rst ---

moviepy.video.compositing.CompositeVideoClip.clips\_array
=========================================================

.. currentmodule:: moviepy.video.compositing.CompositeVideoClip

.. autofunction:: clips_array

--- END moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.clips_array.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.cuts.FramesMatch.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.tools.cuts.FramesMatch
====================================

.. currentmodule:: moviepy.video.tools.cuts

.. autoclass:: FramesMatch
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.tools.cuts.FramesMatch.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.html_embed.rst ---

moviepy.video.io.display\_in\_notebook.html\_embed
==================================================

.. currentmodule:: moviepy.video.io.display_in_notebook

.. autofunction:: html_embed

--- END moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.html_embed.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.apply_to_mask.rst ---

moviepy.decorators.apply\_to\_mask
==================================

.. currentmodule:: moviepy.decorators

.. autofunction:: apply_to_mask

--- END moviepy/docs/reference/reference/moviepy.decorators.apply_to_mask.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.FFmpegInfosParser.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.ffmpeg\_reader.FFmpegInfosParser
=================================================

.. currentmodule:: moviepy.video.io.ffmpeg_reader

.. autoclass:: FFmpegInfosParser
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.FFmpegInfosParser.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips.rst ---

moviepy.video.compositing.CompositeVideoClip.concatenate\_videoclips
====================================================================

.. currentmodule:: moviepy.video.compositing.CompositeVideoClip

.. autofunction:: concatenate_videoclips

--- END moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MakeLoopable.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MakeLoopable
=============================

 
.. automodule:: moviepy.video.fx.MakeLoopable
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MakeLoopable.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.rst ---

﻿.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.tools
=============


.. automodule:: moviepy.tools

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      close_all_clips
      convert_to_seconds
      cross_platform_popen_params
      deprecated_version_of
      find_extension
      no_display_available
      subprocess_call
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.tools.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.readers.FFMPEG_AudioReader.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.io.readers.FFMPEG\_AudioReader
============================================

.. currentmodule:: moviepy.audio.io.readers

.. autoclass:: FFMPEG_AudioReader
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.io.readers.FFMPEG_AudioReader.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.AccelDecel.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.AccelDecel
===========================

 
.. automodule:: moviepy.video.fx.AccelDecel
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.AccelDecel.rst ---



--- START moviepy/docs/reference/reference/moviepy.Clip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.Clip
============


.. automodule:: moviepy.Clip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      Clip
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.Clip.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.requires_fps.rst ---

moviepy.decorators.requires\_fps
================================

.. currentmodule:: moviepy.decorators

.. autofunction:: requires_fps

--- END moviepy/docs/reference/reference/moviepy.decorators.requires_fps.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.AudioFileClip.AudioFileClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.io.AudioFileClip.AudioFileClip
============================================

.. currentmodule:: moviepy.audio.io.AudioFileClip

.. autoclass:: AudioFileClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.io.AudioFileClip.AudioFileClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MultiplySpeed.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MultiplySpeed
==============================

 
.. automodule:: moviepy.video.fx.MultiplySpeed
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MultiplySpeed.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_resize.rst ---

moviepy.video.io.ffmpeg\_tools.ffmpeg\_resize
=============================================

.. currentmodule:: moviepy.video.io.ffmpeg_tools

.. autofunction:: ffmpeg_resize

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_resize.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffplay_previewer.FFPLAY_VideoPreviewer.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.ffplay\_previewer.FFPLAY\_VideoPreviewer
=========================================================

.. currentmodule:: moviepy.video.io.ffplay_previewer

.. autoclass:: FFPLAY_VideoPreviewer
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.ffplay_previewer.FFPLAY_VideoPreviewer.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.ffmpeg_read_image.rst ---

moviepy.video.io.ffmpeg\_reader.ffmpeg\_read\_image
===================================================

.. currentmodule:: moviepy.video.io.ffmpeg_reader

.. autofunction:: ffmpeg_read_image

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.ffmpeg_read_image.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_extract_audio.rst ---

moviepy.video.io.ffmpeg\_tools.ffmpeg\_extract\_audio
=====================================================

.. currentmodule:: moviepy.video.io.ffmpeg_tools

.. autofunction:: ffmpeg_extract_audio

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_extract_audio.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.VideoFileClip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.VideoFileClip
==============================


.. automodule:: moviepy.video.io.VideoFileClip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      VideoFileClip
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.VideoFileClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.AudioClip.AudioClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.AudioClip.AudioClip
=================================

.. currentmodule:: moviepy.audio.AudioClip

.. autoclass:: AudioClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.AudioClip.AudioClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.CrossFadeOut.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.CrossFadeOut
=============================

 
.. automodule:: moviepy.video.fx.CrossFadeOut
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.CrossFadeOut.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Loop.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Loop
=====================

 
.. automodule:: moviepy.video.fx.Loop
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Loop.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.io
================


.. automodule:: moviepy.audio.io

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.audio.io.AudioFileClip


   moviepy.audio.io.ffmpeg_audiowriter


   moviepy.audio.io.ffplay_audiopreviewer


   moviepy.audio.io.readers




--- END moviepy/docs/reference/reference/moviepy.audio.io.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.ffmpeg_audiowriter.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.io.ffmpeg\_audiowriter
====================================


.. automodule:: moviepy.audio.io.ffmpeg_audiowriter

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FFMPEG_AudioWriter
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      ffmpeg_audiowrite
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.io.ffmpeg_audiowriter.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Blink.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Blink
======================

 
.. automodule:: moviepy.video.fx.Blink
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Blink.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.convert_path_to_string.rst ---

moviepy.decorators.convert\_path\_to\_string
============================================

.. currentmodule:: moviepy.decorators

.. autofunction:: convert_path_to_string

--- END moviepy/docs/reference/reference/moviepy.decorators.convert_path_to_string.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.ffmpeg_parse_infos.rst ---

moviepy.video.io.ffmpeg\_reader.ffmpeg\_parse\_infos
====================================================

.. currentmodule:: moviepy.video.io.ffmpeg_reader

.. autofunction:: ffmpeg_parse_infos

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.ffmpeg_parse_infos.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.SlideOut.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.SlideOut
=========================

 
.. automodule:: moviepy.video.fx.SlideOut
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.SlideOut.rst ---



--- START moviepy/docs/reference/reference/moviepy.rst ---

﻿.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy
=======


.. automodule:: moviepy

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.Clip


   moviepy.Effect


   moviepy.audio


   moviepy.config


   moviepy.decorators


   moviepy.tools



   moviepy.video




--- END moviepy/docs/reference/reference/moviepy.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.DataVideoClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.DataVideoClip
=====================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: DataVideoClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.DataVideoClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.LumContrast.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.LumContrast
============================

 
.. automodule:: moviepy.video.fx.LumContrast
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.LumContrast.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.GammaCorrection.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.GammaCorrection
================================

 
.. automodule:: moviepy.video.fx.GammaCorrection
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.GammaCorrection.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.AudioClip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.AudioClip
=======================


.. automodule:: moviepy.audio.AudioClip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      AudioArrayClip
      AudioClip
      CompositeAudioClip
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      concatenate_audioclips
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.AudioClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.tools.cuts.find_audio_period.rst ---

moviepy.audio.tools.cuts.find\_audio\_period
============================================

.. currentmodule:: moviepy.audio.tools.cuts

.. autofunction:: find_audio_period

--- END moviepy/docs/reference/reference/moviepy.audio.tools.cuts.find_audio_period.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.SuperSample.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.SuperSample
============================

 
.. automodule:: moviepy.video.fx.SuperSample
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.SuperSample.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.MultiplyStereoVolume.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.MultiplyStereoVolume
=====================================

 
.. automodule:: moviepy.audio.fx.MultiplyStereoVolume
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.MultiplyStereoVolume.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.MultiplyVolume.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.MultiplyVolume
===============================

 
.. automodule:: moviepy.audio.fx.MultiplyVolume
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.MultiplyVolume.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.tools.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.tools
===================


.. automodule:: moviepy.audio.tools

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.audio.tools.cuts




--- END moviepy/docs/reference/reference/moviepy.audio.tools.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_extract_subclip.rst ---

moviepy.video.io.ffmpeg\_tools.ffmpeg\_extract\_subclip
=======================================================

.. currentmodule:: moviepy.video.io.ffmpeg_tools

.. autofunction:: ffmpeg_extract_subclip

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_extract_subclip.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.AudioFileClip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.io.AudioFileClip
==============================


.. automodule:: moviepy.audio.io.AudioFileClip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      AudioFileClip
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.io.AudioFileClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MasksAnd.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MasksAnd
=========================

 
.. automodule:: moviepy.video.fx.MasksAnd
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MasksAnd.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.BlackAndWhite.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.BlackAndWhite
==============================

 
.. automodule:: moviepy.video.fx.BlackAndWhite
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.BlackAndWhite.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.close_all_clips.rst ---

moviepy.tools.close\_all\_clips
===============================

.. currentmodule:: moviepy.tools

.. autofunction:: close_all_clips

--- END moviepy/docs/reference/reference/moviepy.tools.close_all_clips.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.compositing.CompositeVideoClip
============================================


.. automodule:: moviepy.video.compositing.CompositeVideoClip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      CompositeVideoClip
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      clips_array
      concatenate_videoclips
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.preprocess_args.rst ---

moviepy.decorators.preprocess\_args
===================================

.. currentmodule:: moviepy.decorators

.. autofunction:: preprocess_args

--- END moviepy/docs/reference/reference/moviepy.decorators.preprocess_args.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.subtitles.file_to_subtitles.rst ---

moviepy.video.tools.subtitles.file\_to\_subtitles
=================================================

.. currentmodule:: moviepy.video.tools.subtitles

.. autofunction:: file_to_subtitles

--- END moviepy/docs/reference/reference/moviepy.video.tools.subtitles.file_to_subtitles.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.interpolators.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.tools.interpolators
=================================


.. automodule:: moviepy.video.tools.interpolators

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      Interpolator
      Trajectory
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.tools.interpolators.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.cuts.find_video_period.rst ---

moviepy.video.tools.cuts.find\_video\_period
============================================

.. currentmodule:: moviepy.video.tools.cuts

.. autofunction:: find_video_period

--- END moviepy/docs/reference/reference/moviepy.video.tools.cuts.find_video_period.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.FFMPEG_VideoWriter.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.ffmpeg\_writer.FFMPEG\_VideoWriter
===================================================

.. currentmodule:: moviepy.video.io.ffmpeg_writer

.. autoclass:: FFMPEG_VideoWriter
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.FFMPEG_VideoWriter.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Freeze.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Freeze
=======================

 
.. automodule:: moviepy.video.fx.Freeze
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Freeze.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.AudioClip.CompositeAudioClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.AudioClip.CompositeAudioClip
==========================================

.. currentmodule:: moviepy.audio.AudioClip

.. autoclass:: CompositeAudioClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.AudioClip.CompositeAudioClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.use_clip_fps_by_default.rst ---

moviepy.decorators.use\_clip\_fps\_by\_default
==============================================

.. currentmodule:: moviepy.decorators

.. autofunction:: use_clip_fps_by_default

--- END moviepy/docs/reference/reference/moviepy.decorators.use_clip_fps_by_default.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.EvenSize.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.EvenSize
=========================

 
.. automodule:: moviepy.video.fx.EvenSize
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.EvenSize.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_merge_video_audio.rst ---

moviepy.video.io.ffmpeg\_tools.ffmpeg\_merge\_video\_audio
==========================================================

.. currentmodule:: moviepy.video.io.ffmpeg_tools

.. autofunction:: ffmpeg_merge_video_audio

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_merge_video_audio.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.find_extension.rst ---

moviepy.tools.find\_extension
=============================

.. currentmodule:: moviepy.tools

.. autofunction:: find_extension

--- END moviepy/docs/reference/reference/moviepy.tools.find_extension.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.AudioClip.concatenate_audioclips.rst ---

moviepy.audio.AudioClip.concatenate\_audioclips
===============================================

.. currentmodule:: moviepy.audio.AudioClip

.. autofunction:: concatenate_audioclips

--- END moviepy/docs/reference/reference/moviepy.audio.AudioClip.concatenate_audioclips.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.TimeSymmetrize.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.TimeSymmetrize
===============================

 
.. automodule:: moviepy.video.fx.TimeSymmetrize
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.TimeSymmetrize.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.interpolators.Interpolator.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.tools.interpolators.Interpolator
==============================================

.. currentmodule:: moviepy.video.tools.interpolators

.. autoclass:: Interpolator
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.tools.interpolators.Interpolator.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Rotate.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Rotate
=======================

 
.. automodule:: moviepy.video.fx.Rotate
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Rotate.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.convert_to_seconds.rst ---

moviepy.tools.convert\_to\_seconds
==================================

.. currentmodule:: moviepy.tools

.. autofunction:: convert_to_seconds

--- END moviepy/docs/reference/reference/moviepy.tools.convert_to_seconds.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.drawing.circle.rst ---

moviepy.video.tools.drawing.circle
==================================

.. currentmodule:: moviepy.video.tools.drawing

.. autofunction:: circle

--- END moviepy/docs/reference/reference/moviepy.video.tools.drawing.circle.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.display_in_notebook.rst ---

moviepy.video.io.display\_in\_notebook.display\_in\_notebook
============================================================

.. currentmodule:: moviepy.video.io.display_in_notebook

.. autofunction:: display_in_notebook

--- END moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.display_in_notebook.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.add_mask_if_none.rst ---

moviepy.decorators.add\_mask\_if\_none
======================================

.. currentmodule:: moviepy.decorators

.. autofunction:: add_mask_if_none

--- END moviepy/docs/reference/reference/moviepy.decorators.add_mask_if_none.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.AudioLoop.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.AudioLoop
==========================

 
.. automodule:: moviepy.audio.fx.AudioLoop
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.AudioLoop.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.InvertColors.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.InvertColors
=============================

 
.. automodule:: moviepy.video.fx.InvertColors
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.InvertColors.rst ---



--- START moviepy/docs/reference/reference/moviepy.config.try_cmd.rst ---

moviepy.config.try\_cmd
=======================

.. currentmodule:: moviepy.config

.. autofunction:: try_cmd

--- END moviepy/docs/reference/reference/moviepy.config.try_cmd.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffplay_previewer.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.ffplay\_previewer
==================================


.. automodule:: moviepy.video.io.ffplay_previewer

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FFPLAY_VideoPreviewer
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      ffplay_preview_video
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.ffplay_previewer.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.VideoClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.VideoClip
=================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: VideoClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.VideoClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.credits.CreditsClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.tools.credits.CreditsClip
=======================================

.. currentmodule:: moviepy.video.tools.credits

.. autoclass:: CreditsClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.tools.credits.CreditsClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.convert_masks_to_RGB.rst ---

moviepy.decorators.convert\_masks\_to\_RGB
==========================================

.. currentmodule:: moviepy.decorators

.. autofunction:: convert_masks_to_RGB

--- END moviepy/docs/reference/reference/moviepy.decorators.convert_masks_to_RGB.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.ffmpeg_audiowriter.ffmpeg_audiowrite.rst ---

moviepy.audio.io.ffmpeg\_audiowriter.ffmpeg\_audiowrite
=======================================================

.. currentmodule:: moviepy.audio.io.ffmpeg_audiowriter

.. autofunction:: ffmpeg_audiowrite

--- END moviepy/docs/reference/reference/moviepy.audio.io.ffmpeg_audiowriter.ffmpeg_audiowrite.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.TextClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.TextClip
================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: TextClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.TextClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.display\_in\_notebook
======================================


.. automodule:: moviepy.video.io.display_in_notebook

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      HTML2
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      display_in_notebook
      html_embed
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.interpolators.Trajectory.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.tools.interpolators.Trajectory
============================================

.. currentmodule:: moviepy.video.tools.interpolators

.. autoclass:: Trajectory
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.tools.interpolators.Trajectory.rst ---



--- START moviepy/docs/reference/reference/moviepy.config.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.config
==============


.. automodule:: moviepy.config

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      check
      try_cmd
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.config.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.AudioFadeIn.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.AudioFadeIn
============================

 
.. automodule:: moviepy.audio.fx.AudioFadeIn
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.AudioFadeIn.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.gif_writers.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.gif\_writers
=============================


.. automodule:: moviepy.video.io.gif_writers

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      write_gif_with_imageio
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.gif_writers.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.AudioDelay.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.AudioDelay
===========================

 
.. automodule:: moviepy.audio.fx.AudioDelay
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.AudioDelay.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.ffmpeg_write_video.rst ---

moviepy.video.io.ffmpeg\_writer.ffmpeg\_write\_video
====================================================

.. currentmodule:: moviepy.video.io.ffmpeg_writer

.. autofunction:: ffmpeg_write_video

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.ffmpeg_write_video.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.AudioClip.AudioArrayClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.AudioClip.AudioArrayClip
======================================

.. currentmodule:: moviepy.audio.AudioClip

.. autoclass:: AudioArrayClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.AudioClip.AudioArrayClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.requires_duration.rst ---

moviepy.decorators.requires\_duration
=====================================

.. currentmodule:: moviepy.decorators

.. autofunction:: requires_duration

--- END moviepy/docs/reference/reference/moviepy.decorators.requires_duration.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.AudioNormalize.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.AudioNormalize
===============================

 
.. automodule:: moviepy.audio.fx.AudioNormalize
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.AudioNormalize.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.drawing.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.tools.drawing
===========================


.. automodule:: moviepy.video.tools.drawing

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      blit
      circle
      color_gradient
      color_split
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.tools.drawing.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.CrossFadeIn.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.CrossFadeIn
============================

 
.. automodule:: moviepy.video.fx.CrossFadeIn
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.CrossFadeIn.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.VideoFileClip.VideoFileClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.VideoFileClip.VideoFileClip
============================================

.. currentmodule:: moviepy.video.io.VideoFileClip

.. autoclass:: VideoFileClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.VideoFileClip.VideoFileClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MaskColor.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MaskColor
==========================

 
.. automodule:: moviepy.video.fx.MaskColor
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MaskColor.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip
===============================================================

.. currentmodule:: moviepy.video.compositing.CompositeVideoClip

.. autoclass:: CompositeVideoClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.readers.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.io.readers
========================


.. automodule:: moviepy.audio.io.readers

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FFMPEG_AudioReader
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.io.readers.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffplay_previewer.ffplay_preview_video.rst ---

moviepy.video.io.ffplay\_previewer.ffplay\_preview\_video
=========================================================

.. currentmodule:: moviepy.video.io.ffplay_previewer

.. autofunction:: ffplay_preview_video

--- END moviepy/docs/reference/reference/moviepy.video.io.ffplay_previewer.ffplay_preview_video.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.SlideIn.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.SlideIn
========================

 
.. automodule:: moviepy.video.fx.SlideIn
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.SlideIn.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.ffmpeg\_writer
===============================


.. automodule:: moviepy.video.io.ffmpeg_writer

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FFMPEG_VideoWriter
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      ffmpeg_write_image
      ffmpeg_write_video
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.ffplay_audiopreviewer.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.io.ffplay\_audiopreviewer
=======================================


.. automodule:: moviepy.audio.io.ffplay_audiopreviewer

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FFPLAY_AudioPreviewer
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      ffplay_audiopreview
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.io.ffplay_audiopreviewer.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.no_display_available.rst ---

moviepy.tools.no\_display\_available
====================================

.. currentmodule:: moviepy.tools

.. autofunction:: no_display_available

--- END moviepy/docs/reference/reference/moviepy.tools.no_display_available.rst ---



--- START moviepy/docs/reference/reference/moviepy.config.check.rst ---

moviepy.config.check
====================

.. currentmodule:: moviepy.config

.. autofunction:: check

--- END moviepy/docs/reference/reference/moviepy.config.check.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.ffplay_audiopreviewer.FFPLAY_AudioPreviewer.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.io.ffplay\_audiopreviewer.FFPLAY\_AudioPreviewer
==============================================================

.. currentmodule:: moviepy.audio.io.ffplay_audiopreviewer

.. autoclass:: FFPLAY_AudioPreviewer
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.io.ffplay_audiopreviewer.FFPLAY_AudioPreviewer.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.AudioFadeOut.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx.AudioFadeOut
=============================

 
.. automodule:: moviepy.audio.fx.AudioFadeOut
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.audio.fx.AudioFadeOut.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.audio_video_effect.rst ---

moviepy.decorators.audio\_video\_effect
=======================================

.. currentmodule:: moviepy.decorators

.. autofunction:: audio_video_effect

--- END moviepy/docs/reference/reference/moviepy.decorators.audio_video_effect.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Painting.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Painting
=========================

 
.. automodule:: moviepy.video.fx.Painting
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Painting.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.drawing.color_split.rst ---

moviepy.video.tools.drawing.color\_split
========================================

.. currentmodule:: moviepy.video.tools.drawing

.. autofunction:: color_split

--- END moviepy/docs/reference/reference/moviepy.video.tools.drawing.color_split.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_stabilize_video.rst ---

moviepy.video.io.ffmpeg\_tools.ffmpeg\_stabilize\_video
=======================================================

.. currentmodule:: moviepy.video.io.ffmpeg_tools

.. autofunction:: ffmpeg_stabilize_video

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.ffmpeg_stabilize_video.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Crop.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Crop
=====================

 
.. automodule:: moviepy.video.fx.Crop
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Crop.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.VideoClip
=======================


.. automodule:: moviepy.video.VideoClip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      BitmapClip
      ColorClip
      DataVideoClip
      ImageClip
      TextClip
      UpdatedVideoClip
      VideoClip
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.HeadBlur.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.HeadBlur
=========================

 
.. automodule:: moviepy.video.fx.HeadBlur
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.HeadBlur.rst ---



--- START moviepy/docs/reference/reference/moviepy.Effect.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.Effect
==============

 
.. automodule:: moviepy.Effect
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.Effect.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.ffmpeg_write_image.rst ---

moviepy.video.io.ffmpeg\_writer.ffmpeg\_write\_image
====================================================

.. currentmodule:: moviepy.video.io.ffmpeg_writer

.. autofunction:: ffmpeg_write_image

--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_writer.ffmpeg_write_image.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ImageSequenceClip.ImageSequenceClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.ImageSequenceClip.ImageSequenceClip
====================================================

.. currentmodule:: moviepy.video.io.ImageSequenceClip

.. autoclass:: ImageSequenceClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.ImageSequenceClip.ImageSequenceClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.drawing.blit.rst ---

moviepy.video.tools.drawing.blit
================================

.. currentmodule:: moviepy.video.tools.drawing

.. autofunction:: blit

--- END moviepy/docs/reference/reference/moviepy.video.tools.drawing.blit.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video
=============


.. automodule:: moviepy.video

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.video.VideoClip


   moviepy.video.compositing


   moviepy.video.fx


   moviepy.video.io


   moviepy.video.tools




--- END moviepy/docs/reference/reference/moviepy.video.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ImageSequenceClip.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.ImageSequenceClip
==================================


.. automodule:: moviepy.video.io.ImageSequenceClip

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      ImageSequenceClip
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.ImageSequenceClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.subprocess_call.rst ---

moviepy.tools.subprocess\_call
==============================

.. currentmodule:: moviepy.tools

.. autofunction:: subprocess_call

--- END moviepy/docs/reference/reference/moviepy.tools.subprocess_call.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MultiplyColor.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MultiplyColor
==============================

 
.. automodule:: moviepy.video.fx.MultiplyColor
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MultiplyColor.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.subtitles.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.tools.subtitles
=============================


.. automodule:: moviepy.video.tools.subtitles

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      SubtitlesClip
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      file_to_subtitles
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.tools.subtitles.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Scroll.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Scroll
=======================

 
.. automodule:: moviepy.video.fx.Scroll
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Scroll.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.HTML2.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.io.display\_in\_notebook.HTML2
============================================

.. currentmodule:: moviepy.video.io.display_in_notebook

.. autoclass:: HTML2
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.io.display_in_notebook.HTML2.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.convert_parameter_to_seconds.rst ---

moviepy.decorators.convert\_parameter\_to\_seconds
==================================================

.. currentmodule:: moviepy.decorators

.. autofunction:: convert_parameter_to_seconds

--- END moviepy/docs/reference/reference/moviepy.decorators.convert_parameter_to_seconds.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.ffmpeg_audiowriter.FFMPEG_AudioWriter.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.audio.io.ffmpeg\_audiowriter.FFMPEG\_AudioWriter
========================================================

.. currentmodule:: moviepy.audio.io.ffmpeg_audiowriter

.. autoclass:: FFMPEG_AudioWriter
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.audio.io.ffmpeg_audiowriter.FFMPEG_AudioWriter.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.drawing.color_gradient.rst ---

moviepy.video.tools.drawing.color\_gradient
===========================================

.. currentmodule:: moviepy.video.tools.drawing

.. autofunction:: color_gradient

--- END moviepy/docs/reference/reference/moviepy.video.tools.drawing.color_gradient.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio
=============


.. automodule:: moviepy.audio

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.audio.AudioClip


   moviepy.audio.fx


   moviepy.audio.io


   moviepy.audio.tools




--- END moviepy/docs/reference/reference/moviepy.audio.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.subtitles.SubtitlesClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.tools.subtitles.SubtitlesClip
===========================================

.. currentmodule:: moviepy.video.tools.subtitles

.. autoclass:: SubtitlesClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.tools.subtitles.SubtitlesClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MasksOr.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MasksOr
========================

 
.. automodule:: moviepy.video.fx.MasksOr
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MasksOr.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.BitmapClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.BitmapClip
==================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: BitmapClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.BitmapClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.cuts.FramesMatches.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.tools.cuts.FramesMatches
======================================

.. currentmodule:: moviepy.video.tools.cuts

.. autoclass:: FramesMatches
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.tools.cuts.FramesMatches.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.io.ffplay_audiopreviewer.ffplay_audiopreview.rst ---

moviepy.audio.io.ffplay\_audiopreviewer.ffplay\_audiopreview
============================================================

.. currentmodule:: moviepy.audio.io.ffplay_audiopreviewer

.. autofunction:: ffplay_audiopreview

--- END moviepy/docs/reference/reference/moviepy.audio.io.ffplay_audiopreviewer.ffplay_audiopreview.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.outplace.rst ---

moviepy.decorators.outplace
===========================

.. currentmodule:: moviepy.decorators

.. autofunction:: outplace

--- END moviepy/docs/reference/reference/moviepy.decorators.outplace.rst ---



--- START moviepy/docs/reference/reference/moviepy.audio.fx.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.audio.fx
================


.. automodule:: moviepy.audio.fx

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.audio.fx.AudioDelay


   moviepy.audio.fx.AudioFadeIn


   moviepy.audio.fx.AudioFadeOut


   moviepy.audio.fx.AudioLoop


   moviepy.audio.fx.AudioNormalize


   moviepy.audio.fx.MultiplyStereoVolume


   moviepy.audio.fx.MultiplyVolume




--- END moviepy/docs/reference/reference/moviepy.audio.fx.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.FadeIn.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.FadeIn
=======================

 
.. automodule:: moviepy.video.fx.FadeIn
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.FadeIn.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.apply_to_audio.rst ---

moviepy.decorators.apply\_to\_audio
===================================

.. currentmodule:: moviepy.decorators

.. autofunction:: apply_to_audio

--- END moviepy/docs/reference/reference/moviepy.decorators.apply_to_audio.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Resize.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Resize
=======================

 
.. automodule:: moviepy.video.fx.Resize
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Resize.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.tools
===================


.. automodule:: moviepy.video.tools

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.video.tools.credits


   moviepy.video.tools.cuts


   moviepy.video.tools.drawing


   moviepy.video.tools.interpolators


   moviepy.video.tools.subtitles




--- END moviepy/docs/reference/reference/moviepy.video.tools.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.ffmpeg\_tools
==============================


.. automodule:: moviepy.video.io.ffmpeg_tools

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      ffmpeg_extract_audio
      ffmpeg_extract_subclip
      ffmpeg_merge_video_audio
      ffmpeg_resize
      ffmpeg_stabilize_video
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_tools.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io
================


.. automodule:: moviepy.video.io

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.video.io.ImageSequenceClip


   moviepy.video.io.VideoFileClip


   moviepy.video.io.display_in_notebook


   moviepy.video.io.ffmpeg_reader


   moviepy.video.io.ffmpeg_tools


   moviepy.video.io.ffmpeg_writer


   moviepy.video.io.ffplay_previewer


   moviepy.video.io.gif_writers




--- END moviepy/docs/reference/reference/moviepy.video.io.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.deprecated_version_of.rst ---

moviepy.tools.deprecated\_version\_of
=====================================

.. currentmodule:: moviepy.tools

.. autofunction:: deprecated_version_of

--- END moviepy/docs/reference/reference/moviepy.tools.deprecated_version_of.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.Margin.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.Margin
=======================

 
.. automodule:: moviepy.video.fx.Margin
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.Margin.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MirrorX.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MirrorX
========================

 
.. automodule:: moviepy.video.fx.MirrorX
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MirrorX.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.VideoClip.ColorClip.rst ---

.. custom class to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202

moviepy.video.VideoClip.ColorClip
=================================

.. currentmodule:: moviepy.video.VideoClip

.. autoclass:: ColorClip
   :members:

   

--- END moviepy/docs/reference/reference/moviepy.video.VideoClip.ColorClip.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.TimeMirror.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.TimeMirror
===========================

 
.. automodule:: moviepy.video.fx.TimeMirror
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.TimeMirror.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.cuts.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.tools.cuts
========================


.. automodule:: moviepy.video.tools.cuts

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FramesMatch
      FramesMatches
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      detect_scenes
      find_video_period
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.tools.cuts.rst ---



--- START moviepy/docs/reference/reference/moviepy.tools.cross_platform_popen_params.rst ---

moviepy.tools.cross\_platform\_popen\_params
============================================

.. currentmodule:: moviepy.tools

.. autofunction:: cross_platform_popen_params

--- END moviepy/docs/reference/reference/moviepy.tools.cross_platform_popen_params.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.tools.cuts.detect_scenes.rst ---

moviepy.video.tools.cuts.detect\_scenes
=======================================

.. currentmodule:: moviepy.video.tools.cuts

.. autofunction:: detect_scenes

--- END moviepy/docs/reference/reference/moviepy.video.tools.cuts.detect_scenes.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.compositing.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.compositing
=========================


.. automodule:: moviepy.video.compositing

   

   
   
   


   
   
   


   
   
   



.. rubric:: Modules

.. autosummary::
   :toctree:
   :template: custom_autosummary/module.rst
   :recursive:


   moviepy.video.compositing.CompositeVideoClip




--- END moviepy/docs/reference/reference/moviepy.video.compositing.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.fx.MirrorY.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.fx.MirrorY
========================

 
.. automodule:: moviepy.video.fx.MirrorY
   :inherited-members:

   

   
   
   


   
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.fx.MirrorY.rst ---



--- START moviepy/docs/reference/reference/moviepy.decorators.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.decorators
==================


.. automodule:: moviepy.decorators

   

   
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      add_mask_if_none
      apply_to_audio
      apply_to_mask
      audio_video_effect
      convert_masks_to_RGB
      convert_parameter_to_seconds
      convert_path_to_string
      outplace
      preprocess_args
      requires_duration
      requires_fps
      use_clip_fps_by_default
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.decorators.rst ---



--- START moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.rst ---

.. custom module to enable complete documentation of every function
   see https://stackoverflow.com/a/62613202
   
moviepy.video.io.ffmpeg\_reader
===============================


.. automodule:: moviepy.video.io.ffmpeg_reader

   

   
   
   .. rubric:: Classes

   .. autosummary::
      :toctree:
      :template: custom_autosummary/class.rst
   
      FFMPEG_VideoReader
      FFmpegInfosParser
   
   


   
   
   .. rubric:: Functions

   .. autosummary::
      :toctree:
   
      ffmpeg_parse_infos
      ffmpeg_read_image
   
   


   
   
   





--- END moviepy/docs/reference/reference/moviepy.video.io.ffmpeg_reader.rst ---



--- START moviepy/docs/getting_started/docker.rst ---

MoviePy Docker
===============

Prerequisites
-------------

Docker installed: `Docker Engine for Linux <https://docs.docker.com/engine/install/>`_ or `Docker Desktop for Windows/Mac/Linux <https://docs.docker.com/desktop/>`_.

Build the docker
-----------------
1. Move into the moviepy root dir
2. Build the Dockerfile ::
     
     docker build -t moviepy -f Dockerfile .


How to run the unittests from docker
------------------------------------------------

Run pytest inside the container with the following command ::

     docker run -w /moviepy -it moviepy python -m pytest

Running your own moviepy script from docker
--------------------------------------------

Change directory to where your script is located

If moviepy docker container is already running, you can connect by: ::

     docker exec -it moviepy python myscript.py

If the container isn't running already ::

     docker run -it moviepy bash
     python myscript.py

You can also start a container and run a script in one command: ::

     docker run -it -v `pwd`:/code moviepy python myscript.py


--- END moviepy/docs/getting_started/docker.rst ---



--- START moviepy/docs/getting_started/install.rst ---

.. _install:

Installation
============

Installation is done with ``pip``. If you don't have ``pip``, take a look at `how to install it <https://pip.pypa.io/en/stable/installation/>`_.

With ``pip`` installed, just type this in a terminal:

.. code:: bash

    $ (sudo) pip install moviepy

.. _install-binaries:

Installation of Additional Binaries
-----------------------------------

MoviePy depends on the software ffmpeg_ for video reading and writing and on ``ffplay`` for video previewing.

You don't need to worry about ffmpeg_, as it should be automatically downloaded/installed by ImageIO during your first use of MoviePy (it takes a few seconds).

You do need to worry about ``ffplay`` if you plan on using video/audio previewing. For these cases, make sure to have ``ffplay`` installed (it can usually be found alongside ``ffmpeg``) and ensure it is accessible to Python, or define a custom path (see below).

Define Custom Paths to Binaries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to use a specific version of FFmpeg and FFplay, you can do so using environment variables.

There are a couple of environment variables used by MoviePy that allow you to configure custom paths to the external tools.

To set up any of these variables, the easiest way is to do it in Python before importing objects from MoviePy. For example:

.. code-block:: python

    import os
    os.environ["FFMPEG_BINARY"] = "/path/to/custom/ffmpeg"
    os.environ["FFPLAY_BINARY"] = "/path/to/custom/ffplay"

Alternatively, after installing the optional dependencies, you can create
a ``.env`` file in your working directory that will be automatically read.
For example

.. code-block:: ini

    FFMPEG_BINARY=/path/to/custom/ffmpeg
    FFPLAY_BINARY=/path/to/custom/ffplay

Environment Variables
---------------------

There are two available environment variables for external binaries:

``FFMPEG_BINARY``
    Normally you can leave it at its default ('ffmpeg-imageio'), in which
    case imageio will download the correct ffmpeg binary (on first use) and then always use that binary.

    The second option is ``"auto-detect"``. In this case, ffmpeg will be whatever
    binary is found on the computer: generally ``ffmpeg`` (on Linux/macOS) or ``ffmpeg.exe`` (on Windows).

    Lastly, you can set it to use a binary at a specific location on your disk by specifying the exact path.

``FFPLAY_BINARY``
    The default is ``"auto-detect"``. MoviePy will try to find and use the installed ``ffplay`` binary.

    You can set it to use a binary at a specific location on your disk. On Windows, this might look like:

    .. code-block:: python

        os.environ["FFPLAY_BINARY"] = r"C:\Program Files\ffmpeg\ffplay.exe"

Verify if MoviePy Finds Binaries
--------------------------------

To test if FFmpeg and FFplay are found by MoviePy, in a Python console, you can run:

.. code:: python

    from moviepy.config import check
    check()

.. _ffmpeg: https://www.ffmpeg.org/download.html


--- END moviepy/docs/getting_started/install.rst ---



--- START moviepy/docs/getting_started/index.rst ---

.. _getting_started:

Getting started with MoviePy
------------------------------

This section explain everything you need to start editing with MoviePy. To go further, have a look at the :ref:`user_guide` and the :ref:`reference_manual`.


.. toctree::
   :maxdepth: 1

   install
   quick_presentation
   moviepy_10_minutes
   docker
   updating_to_v2
   FAQ



--- END moviepy/docs/getting_started/index.rst ---



--- START moviepy/docs/getting_started/updating_to_v2.rst ---

.. _updating_to_v2:

Updating from v1.X to v2.X
==========================

MoviePy v2.0 has undergone some large changes with the aim of making the API more consistent
and intuitive. As a result, multiple breaking changes have been made.
Therefore, there is a high likelihood that your pre-v2.0 programs will not run without
some changes.

Dropping support for Python 2
-----------------------------
Starting with version 2.0, MoviePy **no longer supports Python 2**, since Python 2 reached its end of life in 2020. 
Focusing on Python 3.7+ allows MoviePy to take advantage of the latest language features and improvements while maintaining code quality and security. 

Users are encouraged to upgrade to a supported version of Python to continue using MoviePy.

Suppression of ``moviepy.editor`` and simplified importation
------------------------------------------------------------
Before v2.0, it was advised to import from ``moviepy.editor`` whenever you needed to perform some manual operations,
such as previewing or hand editing, because the ``editor`` package handled a lot of magic and initialization, making your life
easier, at the cost of initializing some complex modules like ``pygame``.

With version 2.0, the ``moviepy.editor`` namespace no longer exists. Instead, you should import everything from ``moviepy`` like this:

.. code-block:: python

    from moviepy import *  # Simple and clean; the __all__ is set in moviepy, so only useful things will be loaded
    from moviepy import VideoFileClip  # You can also import only the things you really need

Renaming and API unification
-----------------------------

One of the most significant changes is the renaming of all ``.set_`` methods to ``.with_``. More generally, almost all methods that modify a clip now start
with ``with_``, indicating that they work 'out-of-place', meaning they do not directly modify the clip, but instead copy it, modify the copy, and return the updated copy,
leaving the original clip untouched.

We advise you to check your code for any calls to methods from ``Clip`` objects and verify if there is a matching ``.with_`` equivalent.

Massive refactoring of effects
------------------------------

With version 2.0, effects have undergone significant changes and refactoring. Although the logic of when and why to apply effects remains largely the same, 
the implementation has changed considerably.

If you used any kind of effects, you will need to update your code!

Moving effects from functions to classes
""""""""""""""""""""""""""""""""""""""""""""""

MoviePy version 2.0 introduces a more structured and object-oriented approach to handling effects. Previously, effects were simple Python functions that manipulated video clips or images. 
However, in version 2.0 and onwards, effects are now represented as classes.

This shift allows for better organization, encapsulation, and reusability of code, as well as more comprehensible code. Each effect is now encapsulated within its own class, making it easier to manage and modify. 

All effects now implement the :py:class:`~moviepy.Effect.Effect` abstract class, so if you ever wrote a custom effect.

If you ever wrote your own effect, you will have to migrate to the new object-based implementation. For more information, see :ref:`create_effects`.

Moving from ``clip.fx`` to :py:meth:`~moviepy.Clip.Clip.with_effects`
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The move from functions to objects also meant that MoviePy dropped the method ``Clip.fx`` previously used to apply effects in favor of the new :py:meth:`~moviepy.Clip.Clip.with_effects`.

For more information on how to use effects with v2.0, see :ref:`modifying#effects`.

Removing effects as clip methods
""""""""""""""""""""""""""""""""""

Before version 2.0, when importing from ``moviepy.editor``, effects were added as clip class methods at runtime. This is no longer the case.

If you previously used effects by calling them as clip methods, you must now use :py:meth:`~moviepy.Clip.Clip.with_effects`.

Dropping many external dependencies and unifying the environment
-------------------------------------------------------------

With v1.0, MoviePy relied on many optional external dependencies, attempting to gracefully fall back from one library to another in the event one of them was missing, eventually dropping some features when no library was available.
This resulted in complex and hard-to-maintain code for the MoviePy team, as well as fragmented and hard-to-understand environments for users.

With v2.0, the MoviePy team aimed to offer a simpler, smaller, and more unified dependency list, focusing on ``Pillow`` for all complex image manipulation, and dropping altogether the usage of ``ImageMagick``, ``PyGame``, ``OpenCV``, ``scipy``, ``scikit``, and a few others.

Removed features
-----------------

Unfortunately, reducing the scope of MoviePy and limiting external libraries means that some features had to be removed. If you used any of the following features, you will have to create your own replacements:

- ``moviepy.video.tools.tracking``
- ``moviepy.video.tools.segmenting``
- ``moviepy.video.io.sliders``

Miscellaneous signature changes
-------------------------------

When updating the API and moving from previous libraries to ``Pillow``, some miscellaneous changes also occurred, meaning some method signatures may have changed.

You should check the new signatures if you used any of the following:

- ``TextClip``: Some argument names have changed, and a path to a font file is now needed at object instantiation.
- ``clip.resize`` is now ``clip.resized``.
- ``clip.crop`` is now ``clip.cropped``.
- ``clip.rotate`` is now ``clip.rotated``.
- Any previous ``Clip`` method not starting with ``with_`` now probably starts with it.

Why all these changes and updating from v1.0 to v2.0?
-----------------------------------------------------

You might wonder why all these changes were introduced. The answer is: time.

MoviePy has seen many evolutions since its first release and has become a complex project, with ambitions sometimes too large in relation to the available manpower on the development team.
Over time, as in any project, inconsistencies were introduced to support new functionalities without breaking the current API, and some initial choices no longer reflected the current state of things.

Due to multiple factors, MoviePy underwent a long period during which the main version distributed through PyPi diverged from the GitHub distributed version, causing confusion and chaos.

In an effort to simplify future development and limit confusion by providing a unified environment, it was decided to release a new major version including the many evolutions that happened over the years, which meant breaking changes, and thus a new major version was required.

For anyone interested in how and why all of these decisions were made, you can find much of the discussion in GitHub issues `#1874 <https://github.com/Zulko/moviepy/issues/1874>`_, `#1089 <https://github.com/Zulko/moviepy/issues/1089>`_ and `#2012 <https://github.com/Zulko/moviepy/issues/2012>`_.


--- END moviepy/docs/getting_started/updating_to_v2.rst ---



--- START moviepy/docs/getting_started/quick_presentation.rst ---

.. _quick_presentation:

Quick presentation
===================

This section explains when MoviePy can be used and how it works.

Do I need MoviePy?
~~~~~~~~~~~~~~~~~~~

Here are a few reasons why you may want to edit videos in Python:

- You have many videos to process or to compose in a complicated way.
- You want to automate the creation of videos or GIFs on a web server (Django, Flask, etc.)
- You want to automate tedious tasks, like title insertions tracking objects, cutting scenes, making end credits, subtitles, etc...
- You want to code your own video effects to do something no existing video editor can.
- You want to create animations from images generated by another python library (Matplotlib, Mayavi, Gizeh, scikit-images...)

And here are a few uses for which MoviePy is NOT the best solution:

- You only need to do frame-by-frame video analysis (with face detection or other fancy stuff). This could be done with MoviePy in association with other libraries, but really, just use imageio_, OpenCV_ or SimpleCV, these are libraries that specialize in these tasks.
- You only want to convert a video file, or turn a series of image files into a movie. In this case it is better to directly call ``ffmpeg`` (or ``avconv`` or ``mencoder``...) as it will be faster and more memory-efficient than going through MoviePy.


Advantages and limitations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

MoviePy has been developed with the following goals in mind:

- **Simple and intuitive**. Basic operations can be done in one line. The code is easy to learn and easy to understand for newcomers.
- **Flexible**. You have total control over the frames of the video and audio, and creating your own effects is easy as Py.
- **Portable**. The code uses very common software (Numpy and FFmpeg) and can run on (almost) any machine with (almost) any version of Python.

Limitations:
- MoviePy cannot stream videos (e.g. reading from a webcam, or rendering a video live on a distant machine).
- MoviePy is not really designed for video processing involving many successive frames of a movie (e.g. video stabilization - there is other software better suited for that).
- You can also have memory problems if you use many video, audio, and image sources at the same time (>100).

Example code
~~~~~~~~~~~~~~

In a typical MoviePy script, you load video or audio files, modify them, put them together, and write the final result to a new video file. As an example, let us load a video, lower the volume, add a title in the center of the video for the first ten seconds, and write the result in a file: 

.. literalinclude:: /_static/code/getting_started/quick_presentation/basic_example.py
    :language: python


How MoviePy works
~~~~~~~~~~~~~~~~~~~

MoviePy uses the software ``ffmpeg`` to read and to export video and audio files. It also (optionally) uses ``ffplay`` to allow for video previewing.

Internally, the representation and manipulation of the different media is done using Python's fast numerical library Numpy. Advanced effects and enhancements also use ``pillow`` library.

.. image:: /_static/medias/getting_started/explanations.jpeg
    :width: 570px
    :align: center


The central concept, the clips
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The central object of MoviePy is the the :py:class:`Clip <moviepy.Clip.Clip>`, with either :py:class:`~moviepy.audio.AudioClip.AudioClip` for any audio element, or :py:class:`~moviepy.video.VideoClip.VideoClip` for any visual element. Clips really are the base unit of MoviePy, everything you do is with and on them.

Clips can be created from more than just videos or audios though. They can also be created from an image, a text, a custom animation, a folder of images, and even a simple lambda function!

To create your final video, what you will do is essentially:   

#. Load different resources as clips (see :ref:`loading`)
#. Modify them (see :ref:`modifying`)
#. Mixing them into one final clip (see :ref:`compositing`)
#. Render them into a file (see :ref:`rendering`)

Of course, MoviePy offer multiple handy solution and tools to facilitate all these steps, and lets you add new ones by writing your own effects (see :ref:`create_effects`)!


.. _imageio: https://imageio.github.io/
.. _OpenCV: http://opencv.org/







--- END moviepy/docs/getting_started/quick_presentation.rst ---



--- START moviepy/docs/getting_started/moviepy_10_minutes.rst ---

.. _moviepy_10_minutes:

MoviePy in 10 Minutes: Creating a Trailer from "Big Buck Bunny"
===============================================================

.. note::
   This tutorial aims to be a simple and short introduction for new users wishing to use MoviePy. For a more in-depth exploration of the concepts seen in this tutorial, see :ref:`user_guide`.

In this tutorial, you will learn the basics of how to use the MoviePy library in just 10 minutes. As an example project for this tutorial, we will create the following trailer for the movie `"Big Buck Bunny." <https://peach.blender.org/>`_

.. raw:: html

   <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; margin-bottom:30px; height: 0; overflow: hidden; margin-left: 5%;">
      <video controls>
         <source src="/moviepy/_static/medias/getting_started/moviepy_10_minutes/trailer_bbb.mp4" type="video/mp4">
         <p>Your browser does not support HTML5 video in MP4 format.</p>
      </video>
   </div>

Prerequisites
-------------

Before we start, make sure you have MoviePy installed. You can install it using pip:

.. code-block:: shell

   pip install moviepy

Additionally, we will need to gather a few resources such as the original movie, font files, images, etc. To make it easy, we have prepared a template project you can download directly:

1. Download :download:`the project template </_static/medias/getting_started/moviepy_10_minutes/moviepy_10_minutes.zip>` and unzip it.
2. Take a look at the resources inside the folder to familiarize yourself.
3. Create a Python script file named ``trailer.py`` in the project directory.

Now, you are ready to proceed to the next steps.

Step 1: Import MoviePy and Load the Video
-----------------------------------------

Let's start by importing the necessary modules and loading the "Big Buck Bunny" video into our Python program:

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
   :language: python
   :lines: 1-10

As you can see, loading a video file is really easy, but MoviePy isn't limited to video. It can handle images, audio, text, and even custom animations.

No matter the kind of resources, ultimately any clip will be either a :py:class:`~moviepy.video.VideoClip.VideoClip` for any visual element, and an :py:class:`~moviepy.audio.AudioClip.AudioClip` for any audio element.

In this tutorial, we will only see a few of those, but if you want to explore more, you can find an exhaustive list in the user guide about :ref:`loading`.

Step 2: Extract the Best Scenes
-------------------------------

To create our trailer, we will focus on presenting the main characters, so we need to extract parts of the movie. This is a very classic task, so let's turn our main clip into multiple subclips:

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
   :language: python
   :lines: 13-25

Here, we use the ``subclip`` method to extract specific scenes from the main video. We provide the start and end times (in seconds or as text with the format ``HH:MM:SS.µS``) for each scene. The extracted clips are stored in their respective variables (``intro_clip``, ``bird_clip``, etc.).

Step 3: Take a First Look with Preview
--------------------------------------

When editing videos, it's often essential to preview the clips to ensure they meet our vision. This allows you to watch the segment you're working on and make any necessary adjustments for the perfect result.

To do so using MoviePy, you can utilize the ``preview()`` function available for each clip (the complementary ``audio_preview()`` is also available for :py:class:`~moviepy.audio.AudioClip.AudioClip`).

.. note::
   Note that you will need ``ffplay`` installed and accessible to MoviePy for preview to work. You can check if ``ffplay`` is available by running the command ``python3 -c "from moviepy.config import check; check()"``.
   If not, please see :ref:`install#binaries`.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
   :language: python
   :lines: 28-38

By using the preview, you may have noticed that our clips not only contain video but also audio. This is because when loading a video, you not only load the image but also the audio tracks that are turned into :py:class:`~moviepy.audio.AudioClip.AudioClip` and added to your video clip.

.. note::
   When previewing, you may encounter video slowing or video/audio shifting. This is not a bug; it's due to the fact that your computer cannot render the preview in real-time. In such a case, the best course of action is to set the ``fps`` parameter for the ``preview()`` at a lower value to make things easier on your machine.

Step 4: Modify a Clip by Cutting Out a Part of It
--------------------------------------------------

After previewing the clips, we notice that the rodents' scene is a bit long. Let's modify the clip by removing a specific part. It would be nice to remove parts of the scene that we don't need. This is also quite a common task in video editing. To do so, we are going to use the ``with_effects`` method to remove a portion of the clip between ``00:06:00`` to ``00:10:00``.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
   :language: python
   :lines: 41-54

In that particular case, we have used the ``with_effects``, but this is only one of the many clip manipulation methods starting with ``with_``. We will see a few others in this tutorial, but we will miss a lot more. If you want an exhaustive list, go see :ref:`reference_manual`.

.. note::
   You may have noticed that we have reassigned the ``rodents_clip`` variable instead of just calling a method on it. This is because in MoviePy, any function starting with ``with_`` is out-of-place instead of in-place, meaning it does not modify the original data but instead copies it and modifies/returns the copy. So you need to store the result of the method and, if necessary, reassign the original variable to update your clip.

Step 5: Creating Text/Logo Clips
------------------------------------

In addition to videos, we often need to work with images and texts. MoviePy offers some specialized kinds of :py:class:`~moviepy.video.VideoClip.VideoClip` specifically for that purpose: ``ImageClip`` and ``TextClip``.

In our case, we want to create text clips to add text overlays between the video clips. We'll define the font, text content, font size, and color for each text clip. We also want to create image clips for the "Big Buck Bunny" logo and the "Made with MoviePy" logo and resize them as needed.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 56-82

As you can see, ``ImageClip`` is quite simple, but ``TextClip`` is a rather complicated object. Don't hesitate to explore the arguments it accepts.

.. note::
   In our example, we have used the ``resize`` method to resize our image clips. This method works just like any ``with_*`` method, but because resizing is such a common task, the name has been shortened to ``resize``. The same is true for ``crop`` and ``rotate``.

Feel free to experiment with different effects and transitions to achieve the desired trailer effect.

Step 6: Timing the Clips
------------------------

We have all the clips we need, but if we were to combine all the clips into a single one using composition (we will see that in the next step), all our clips would start at the same time and play on top of each other, which is obviously not what we want. Also, some video clips, like images and texts, have no endpoint/duration at creation (unless you have provided a duration parameter), which means trying to render them will throw an error as it would result in an infinite video.

To fix that, we need to specify when a clip should start and stop in the final clip. So, let's start by indicating when each clip must start and end using the appropriate ``with_*`` methods.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 85-111

.. note::
   By default, all clips have a start point at ``0``. If a clip has no ``duration`` but you set the ``end_time``, then the ``duration`` will be calculated for you. The reciprocity is also true.

   So in our case, we either use ``duration`` or ``end_time``, depending on what is more practical for each specific case.

Step 7: Seeing How All Clips Combine
------------------------------------

Now that all our clips are timed, let's get a first idea of how our final clip will look. In video editing, the act of assembling multiple videos into a single one is known as composition. So, MoviePy offers a special kind of :py:class:`~moviepy.video.VideoClip.VideoClip` dedicated to the act of combining multiple clips into one, the :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

:py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` takes an array of clips as input and will play them on top of each other at render time, starting and stopping each clip at its start and end points.

.. note::
   If possible, :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` will extract endpoint and size from the biggest/last ending clip. If a clip in the list has no duration, then you will have to manually set the duration of :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` before rendering.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 114-136

Step 8: Positioning Our Clips
-----------------------------

By looking at this first preview, we see that our clips are pretty well timed, but that the positions of our texts and logo are not satisfying.

This is because, for now, we have only specified when our clips should appear, and not the position at which they should appear. By default, all clips are positioned from the top left of the video, at ``(0, 0)``.

All our clips do not have the same sizes (the texts and images are smaller than the videos), and the :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` takes the size of the biggest clip (so in our case, the size of the videos), so the texts and images are all in the top left portion of the clip.

To fix this, we simply have to define the position of our clips in the composition with the method ``with_position``.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 139-174

.. note::
   The position is a tuple with horizontal and vertical position. You can give them as pixels, as strings (``top``, ``left``, ``right``, ``bottom``, ``center``), and even as a percentage by providing a float and passing the argument ``relative=True``.

Now, all our clips are in the right place and timed as expected.

Step 9: Adding Transitions and Effects
--------------------------------------

So, our clips are timed and placed, but for now, the result is quite raw. It would be nice to have smoother transitions between the clips. In MoviePy, this is achieved through the use of effects.

Effects play a crucial role in enhancing the visual and auditory appeal of your video clips. Effects are applied to clips to create transitions, transformations, or modifications, resulting in better-looking videos. Whether you want to add smooth transitions between clips, alter visual appearance, or manipulate audio properties, MoviePy comes with many existing effects to help you bring your creative vision to life with ease.

You can find these effects under the namespace ``vfx`` for video effects and ``afx`` for audio effects.

.. note::
   You can use audio effects on both audio and video clips because when applying audio effects to a video clip, the effect will actually be applied to the video clip's embedded audio clip instead.

Using an effect is very simple. You just have to call the method ``with_effects`` on your clip and pass an array of effect objects to apply.

In our case, we will add simple fade-in/out and cross-fade-in/out transitions between our clips, as well as slow down the ``rambo_clip``.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 177-239

Well, this looks a lot nicer! For this tutorial, we want to keep things simple, so we mostly used transitions. However, you can find many different effects and even create your own. For a more in-depth presentation, see :py:mod:`moviepy.video.fx`, :py:mod:`moviepy.audio.fx`, and :ref:`create_effects`.

.. note::
   Looking at the result, you may notice that cross-fading makes clips go from transparent to opaque, and reciprocally, and wonder how it works.

   We won't get into details, but know that in MoviePy, you can declare some sections of a video clip to be transparent by using masks. Masks are nothing more than special kinds of video clips that are made of values ranging from ``0`` for a transparent pixel to ``1`` for a fully opaque one.

   For more info, see :ref:`loading#masks`.

Step 10: Modifying the Appearance of a Clip Using Filters
---------------------------------------------------------

Finally, to make it more epic, we will apply a custom filter to our Rambo clip to make the image sepia. MoviePy does not come with a sepia effect out of the box, and creating a full custom effect is beyond the scope of this tutorial. However, we will see how we can apply a simple filter to our clip using the :py:meth:`~moviepy.video.VideoClip.VideoClip.image_transform` method.

To understand how filters work, you first need to understand that in MoviePy, a clip frame is nothing more than a numpy ``ndarray`` of shape ``HxWx3``. This means we can modify how a frame looks like by applying simple math operations. Doing that on all the frames allows us to apply a filter to our clip!

The "apply to all frames" part is done by the ``image_transform`` method. This method takes a callback function as an argument, and at render time, it will trigger the callback for each frame of the clip, passing the current frame.

.. warning::
   This is a bit of an advanced usage, and the example involves matrix multiplication. If this is too much for you, you can simply ignore it until you really need to make custom filters, then go look for a more detailed explanation on how to do filtering (:ref:`modifying#filters`) and create custom effects (:ref:`create_effects`) in the user guide.

   What you need to remember is just that we can apply filters on images. Here we do it mathematically, but you could very well use a library such as Pillow (provided it can understand numpy images) to do the maths for you!

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 242-283

Step 11: Rendering the Final Clip to a File
-------------------------------------------

So, our final clip is ready, and we have made all the cutting and modifications we want. We are now ready to save the final result into a file. In video editing, this operation is known as rendering.

Again, we will keep things simple and just do video rendering without much tweaking. In most cases, MoviePy and FFmpeg will automatically find the best settings. Take a look at :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile` for more info.

.. literalinclude:: /_static/code/getting_started/moviepy_10_minutes/trailer.py
    :language: python
    :lines: 286-307

Conclusion
----------

Congratulations! You have successfully created a trailer for the movie "Big Buck Bunny" using the MoviePy library. This tutorial covered the basics of MoviePy, including loading videos, trimming scenes, adding effects and transitions, overlaying text, and even a little bit of filtering.

If you want to dig deeper into MoviePy, we encourage you to try and experiment with this base example by using different effects, transitions, and audio elements to make your trailer truly captivating. We also encourage you to go and read the :ref:`user_guide`, as well as looking directly at the :ref:`reference_manual`.


--- END moviepy/docs/getting_started/moviepy_10_minutes.rst ---



--- START moviepy/docs/getting_started/FAQ.rst ---

FAQ and troubleshooting
=========================

This section intend to answer the most common questions and errors.

Common errors that are not bugs
--------------------------------

These are very common errors which are not considered as bugs to be
solved (but you can still ask for this to change). If these answers
don't work for you, please open a bug report on Github_, or on the dedicated Subreddit_.


MoviePy generated a video that cannot be read by my favorite player.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Known reason: one of the video's dimensions were not even,
for instance 720x405, and you used a MPEG4 codec like libx264 (default
in MoviePy). In this case the video generated uses a format that is
readable only on some readers like VLC.


I can't seem to read any video with MoviePy
""""""""""""""""""""""""""""""""""""""""""""""

Known reason: you have a deprecated version of FFmpeg, install a recent version from the
website, not from your OS's repositories! (see :ref:`install`).


Previewing videos make them slower than they are
"""""""""""""""""""""""""""""""""""""""""""""""""

It means that your computer is not good enough to render the clip in real time. Don't hesitate to play with the options of ``preview``: for instance, lower the fps of the sound (11000 Hz is still fine) and the video. Also, downsizing your video with ``resize`` can help.

.. _Github: https://github.com/Zulko/moviepy
.. _Subreddit: https://www.reddit.com/r/moviepy/



--- END moviepy/docs/getting_started/FAQ.rst ---

